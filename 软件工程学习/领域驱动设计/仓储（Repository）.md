在领域驱动设计（DDD）中，==**仓储（Repository）** 是一个非常重要的模式，它在领域模型和数据持久化机制之间提供了一层抽象。==你可以把它想象成一个**虚拟的集合**，领域层可以通过这个集合来存储、检索和管理它的**聚合根（Aggregate Root）**。

### 为什么需要仓储？

在没有仓储模式的情况下，==领域逻辑可能会直接与数据库操作耦合，例如，实体内部可能包含保存、更新、删除自己的方法==，或者业务服务直接调用底层的 SQL 语句或 ORM 框架。这种做法会导致几个问题

- **领域层被污染：** 业务逻辑与数据持久化逻辑混杂在一起，使得领域模型不再纯粹，难以聚焦于业务本身。
- **测试困难：** 单元测试领域逻辑时，需要连接真实数据库，这会使测试变得缓慢且复杂。
- **可变性差：** 如果底层数据存储技术发生变化（比如从关系型数据库切换到 NoSQL 数据库），会影响到大量的领域代码。
- **业务意图模糊：** 代码中充斥着技术细节，而不是清晰地表达业务意图。

仓储模式正是为了解决这些问题而生。==它将数据访问的复杂性封装起来，让领域层可以专注于表达业务==，而无需关心数据是如何被存储或检索的。

### 仓储的核心职责

仓储的主要职责是：

1. ==**提供聚合根的集合语义：** 它对外提供的方法，就像操作一个内存中的集合一样==，比如 `Add(aggregateRoot)`、`GetById(id)`、`Remove(aggregateRoot)`、`GetAll()` 或 `FindByCriteria(criteria)`。
2. ==**封装数据持久化逻辑：** 仓储内部负责将领域对象（特别是聚合根）转换为数据库可以存储的格式，并执行实际的数据库操作（CRUD：创建、读取、更新、删除）。==
3. ==**维护聚合根的生命周期：** 仓储是聚合根的持久化边界==。每次从仓储获取一个聚合根，它都是一个完整的、一致的聚合。==保存聚合根时，仓储会负责将其内部所有相关的实体和值对象一同持久化==。
4. **查询能力：** ==提供根据特定条件查询聚合根的能力，但这些查询应该返回完整的聚合根==，而不是部分数据。

### 仓储的实现原则

1. **一个聚合根一个仓储：** ==通常情况下，**每个聚合根对应一个仓储**。这意味着你不会有“订单项仓储”或“地址仓储”==，因为订单项和地址都是“订单”聚合内部的对象，它们的持久化应该通过“订单仓储”来完成。
2. **返回完整的聚合根：** 仓储的方法应该返回一个完整的、一致的聚合根实例，而不是只返回其部分数据。
3. **不返回内部实体或值对象：** ==你不应该从仓储中直接获取聚合内部的实体或值对象。所有对聚合内部对象的访问和修改都应该通过聚合根进行。==
4. **接口与实现分离：** ==仓储通常由一个接口（定义领域层需要的操作）和多个实现（针对不同的数据存储技术）组成==。领域层只依赖接口，不关心具体实现。
5. **关注业务意图：** 仓储的方法名应该反映业务意图，例如 `OrderRepository.GetOrderById(orderId)` 而不是 `OrderRepository.SelectOrderFromDatabase(id)`。

### 仓储在 DDD 中的位置

仓储通常位于**基础设施层（Infrastructure Layer）**，或者至少是**领域层（Domain Layer）**和基础设施层之间的桥梁。==领域层通过仓储接口与数据持久化机制解耦==，而具体的仓储实现则处理与数据库、文件系统或其他外部存储的交互