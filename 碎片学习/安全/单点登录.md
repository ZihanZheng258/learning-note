==单点登录英文全称Single Sign On，简称就是SSO。它的解释是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统。==例如，网页登录了淘宝账号，天猫，钉钉等阿里系应用都不用再二次登录了。 SSO核心意义就一句话：一处登录，处处登录；一处注销，处处注销。就是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统，即用户只需要记住一组用户名和密码就可以登录所有有权限的系统。
![[Pasted image 20250506170128.png]]
### SSO体系中的角色

一般SSO体系主要角色有三种：  
1、 User（多个）  
2、 Web应用（多个）  
3、 SSO认证中心（1个）

### SSO实现模式的原则

SSO实现模式一般包括以下三个原则：  
1、 所有的认证登录都在SSO认证中心进行；  
2、 SSO认证中心通过一些方法来告诉 Web 应用当前访问用户究竟是不是已通过认证的用户；  
3、 SSO 认证中心和所有的 Web 应用建立一种信任关系，也就是说web应用必须信任认证中心。（单点信任）


单点登录可以有这些实现方案:

## 基于Cookie的单点登录
这是最简单的单点登录实现方式，是使用cookie作为媒介，存放用户凭证。 用户登录父应用之后，应用返回一个加密的cookie，当用户访问子应用的时候，携带上这个cookie，授权应用解密cookie并进行校验，校验通过则登录当前用户。

不难发现以上方式把信任存储在客户端的Cookie中，这种方式很容易令人质疑：

Cookie不安全
不能跨域实现免登

对于第一个问题，通过加密Cookie可以保证安全性，当然这是在源代码不泄露的前提下。如果Cookie的加密算法泄露，攻击者通过伪造Cookie则可以伪造特定用户身份，这是很危险的。

对于第二个问题，不能跨域实现免登更是硬伤。因此，有了基于Session的单点登录。

## Broker-based(基于经纪人)  
这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的"第三方"。例如Kerberos、Sesame、IBM KryptoKnight（凭证库思想)等。Kerberos是由麻省理工大学发明的安全认证服务，已经被UNIX和Windows作为默认的安全认证服务集成进操作系统。

## Agent-based（基于代理人）
在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个"翻译"。例如SSH等。

## 基于Session的单点登录
Session解决了Cookie不能跨域的问题，但也存在其他问题。早期的单体应用使用Session实现单点登录，但现在大部分情况下都需要集群，由于存在多台服务器，Session在多台服务器之间是不共享的，因此，还需解决Session共享的问题

解决系统之间的 Session 不共享问题有以下几种方案：

Tomcat集群Session全局复制（集群内每个tomcat的session完全同步）【会影响集群的性能呢，不建议】
根据请求的IP进行Hash映射到对应的机器上（这就相当于请求的IP一直会访问同一个服务器）【如果服务器宕机了，会丢失了一大部分Session的数据，不建议】
分布式Session，即把Session数据放在Redis中（使用Redis模拟Session）【建议】


# 常见方案
## CAS

CAS（Central Authentication Service） 是 Yale大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法（属于Web SSO）。 

CAS开始于2001年， 并在 2004年 12月正式成为JA-SIG的一个项目。

从结构体系看，CAS包括两部分：CAS Server和CAS Client。

###  CAS Server

CAS Server负责完成对用户的认证工作, 需要独立部署, CAS Server 会处理用户名 / 密码等凭证 (Credentials)。

### CAS Client

负责处理对客户端受保护资源的访问请求，需要对请求方进行身份认证时，重定向到CAS Server进行认证。（原则上，客户端应用不再接受任何的用户名密码等 Credentials）。  
CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护受保护的资源。

## 基础模式
基础模式SSO访问流程主要有以下步骤：

1. 访问服务：SSO客户端发送请求访问应用系统提供的服务资源。  
    
2. 定向认证：SSO客户端会重定向用户请求到SSO服务器。  
    
3. 用户认证：用户身份认证。  
    
4. **发放票据：SSO服务器会产生一个随机的Service Ticket。**  
    
5. 验证票据：SSO服务器验证票据Service Ticket的合法性，验证通过后，允许客户端访问服务。  
    
6. 传输用户信息：SSO服务器验证票据通过后，传输用户认证结果信息给客户端

![[Pasted image 20250507100924.png]]

如上图：CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护Web应用的受保护资源，过滤从客户端过来的每一个Web请求，==同时，CAS Client 会分析HTTP请求中是否包含请求Service Ticket( ST上图中的Ticket)== ，如果没有，则说明该用户是没有经过认证的；==于是CAS Client 会重定向用户请求到 CAS Server（Step 2），并传递Service（要访问的目的资源地址）==。 Step 3是用户认证过程，如果用户提供了正确的Credentials， CAS Server随机产生一个相当长度、唯一、不可伪造的Service Ticket，并缓存以待将来验证，并且重定向用户到Service 所在地址（附带刚才产生的Service Ticket ）, ==并为客户端浏览器设置一个Ticket Granted Cookie（TGC）==；CAS Client 在拿到Service和新产生的 Ticket过后，在Step 5和Step6中与CAS Server进行身份核实，以确保 Service Ticket 的合法性。

在该协议中，**所有与CAS Server的交互均采用SSL协议，以确保ST和TGC的安全性**。协议工作过程中会有2次重定向的过程。但是 CAS Client与CAS Server之间进行Ticket验证的过程对于用户是透明的（使用HttpsURLConnection）

当用户访问另一个应用的服务再次被重定向到CAS Server的时候，CAS Server会主动获到这个TGC cookie，然后做下面的事情：

1. 如果User持有TGC且其还没失效，那么就走基础协议图的Step4，达到了 SSO 的效果；  
    
2. 如果TGC失效，那么用户还是要重新认证 (走基础协议图的Step3)。

## 总结
CAS的SSO实现方式可简化理解为：1个Cookie和N个Session。CAS Server创建cookie，在所有应用认证时使用，各应用通过创建各自的Session来标识用户是否已登录。  

用户在一个应用验证通过后，以后用户在同一浏览器里访问此应用时，客户端应用中的过滤器会在session里读取到用户信息，所以就不会去CAS Server认证。如果在此浏览器里访问别的web应用时，客户端应用中的过滤器在session里读取不到用户信息，就会去CAS Server的login接口认证，但这时CAS Server会读取到浏览器传来的cookie（TGC），所以CAS Server不会要求用户去登录页面登录，只是会根据service参数生成一个Ticket，然后再和web应用做一个验证ticket的交互而已。 
个人注：Token是ticket的一种实现方式

## 附录

CAS系统中设计了5中票据：TGC、ST、PGT、PGTIOU、PT。 

Ø Ticket-granting cookie(TGC)：存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，并且只能基于安全通道传输（Https），是CAS Server用来明确用户身份的凭证；

Ø Service ticket(ST)：服务票据，服务的惟一标识码,由CAS Server发出（Http传送），通过客户端浏览器到达业务服务器端；一个特定的服务只能有一个惟一的ST；  

Ø Proxy-Granting ticket（PGT）：由CAS Server颁发给拥有ST凭证的服务，PGT绑定一个用户的特定服务，使其拥有向CAS Server申请，获得PT的能力；  

Ø Proxy-Granting Ticket I Owe You（PGTIOU）:作用是将通过凭证校验时的应答信息由CAS Server 返回给CAS Client，同时，与该PGTIOU对应的PGT将通过回调链接传给Web应用。Web应用负责维护PGTIOU与PGT之间映射关系的内容表；  

Ø Proxy Ticket (PT)：是应用程序代理用户身份对目标程序进行访问的凭证；

对于一个 CAS 用户来说，最重要是要保护它的TGC，如果TGC不慎被CAS Server以外的实体获得，Hacker能够找到该TGC，然后冒充CAS用户访问所有授权资源。PGT的角色跟TGC是一样的。  
从基础模式可以看出， TGC是CAS Server通过SSL方式发送给终端用户，因此，要截取TGC难度非常大，从而确保CAS的安全性。

TGT的存活周期默认为120分钟。