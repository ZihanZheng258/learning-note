所谓 SQL 注入，==就是通过将 SQL 命令插入应用程序的 http 请求中，并在服务器端被接收后用于参与数据库操作，最终达到欺骗服务器执行恶意的 SQL 命令的效果==。理论上来讲，应用程序中只要是与数据库有数据交互的地方，无论是增删改查，如果数据完全受用户控制，而应用程序又处理不当，那么这些地方都是可能存在 SQL 注入的。

### 如何防御?

常见的修复方法：

- **使用预编译处理输入参数**：要防御 SQL 注入，用户的输入就不能直接嵌套在 SQL 语句当中。使用参数化的语句，用户的输入就被限制于一个参数当中。

> # **为什么预编译可以防止注入攻击**
> 
> 核心在于**将 SQL 语句的结构和数据分离开来处理**。你可以把它想象成一份带有占位符的合同模板。
> 
> ==注入攻击的核心在于通过在输入中插入恶意的 SQL 代码，改变原始 SQL 语句的意图。==但是，当使用预编译语句时，用户输入的部分被严格地视为参数数据，即使包含 SQL 关键字或特殊字符，也不会被数据库引擎解释为可执行的 SQL 代码。
> 
> ==由于预编译阶段在真正填充参数之前，语法树就已经被固定，所以参数不再能改动sql语句结构==

- **输入验证**：==检查用户输入的合法性，以确保输入的内容为正常的数据。==数据检查应当在客户端和服务器端都执行，之所以要执行服务器端验证，是因为客户端的校验往往只是减轻服务器的压力和提高对用户的友好度，==攻击者完全有可能通过抓包修改参数或者是获得网页的源代码后，修改验证合法性的脚本（或者直接删除脚本），然后将非法内容通过修改后的表单提交给服务器等等手段绕过客户端的校验。==因此，要保证验证操作确实已经执行，唯一的办法就是在服务器端也执行验证。但是这些方法很容易出现由于过滤不严导致恶意攻击者可能绕过这些过滤的现象，需要慎重使用。
    
- **错误消息处理**：防范 SQL 注入，==还要避免出现一些详细的错误消息，恶意攻击者往往会利用这些报错信息来判断后台 SQL 的拼接形式==，甚至是直接利用这些报错注入将数据库中的数据通过报错信息显示出来。
    
- **加密处理**：将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入 SQL 命令。
    

## [#](#xpath-注入) xPath 注入

---

著作权归@pdai所有 原文链接：https://pdai.tech/md/develop/security/dev-security-x-injection.html