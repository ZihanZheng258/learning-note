对于一些业务玩法相对复杂的系统，例如订单交易，电商促销等场景，如果单靠我们程序猿发挥个人才能来写代码，由于人员变动和技术水平不一，代码增量较大，==我们很容易在会形成一些十分臃肿的方法、类，比如一个方法里面涵盖好几种，甚至上10种场景的流转，对于后续的维护代码的成本指数上升。==

所以引入业务编排的设计思想有很大的好处，==在我看来，如果有一个可视化的关系调用链路，以组件（类）的维度来编排一个业务流程，复用性也增强很多，也可以做到高度自定义。==

同样，如果业务代码量十分巨大，且业务十分复杂，哪怕我们使用业务编排来设计，我们阅读代码的时候也同样需要投入一定的时间。尤其是设计业务编排需要一套“轮子”框架，==如果我们对这个框架的全局没有掌握，我们是很难去阅读代码的。==相反，当我们把这个业务编排的框架入门了以后，我们就很轻易地知道每个调用链是怎样串联起来的，如果还有可视化工具，那我们就更容易地阅读和熟悉这个代码。

 有一些很重量的流程审批和流程编排的工具，比如Activiti，这些经常用于OA系统上，做一些更接近场景的系统。我理解，如果单纯想满足业务编排，一些轻量级的工具是首选，比如上面说的LiteFlow

![[Pasted image 20250525091420.png]]

兜底是通过采集信息流频道历史分发过的高热内容，如果这是一个关注频道，在推荐返回空的时候出兜底则会有损用户体验，因此关注频道通常不会配置兜底，那么按上述DAG的结构，如果判断其为关注频道则不会去请求兜底

类似频道类型这种实体的类型/状态/流量类型/业务场景等控制信息会作为变化的部分被配置化，而具体提供某种处理能力的函数作为不变的Task存在。

如此我们只需要在请求到来时，根据变化的配置信息对DAG进行初始化，根据上下文中的信息，每个node决定是否真的执行具体的task(跳过)，将业务组件最大程度的复用和内聚以及限定了延迟的极限上界。