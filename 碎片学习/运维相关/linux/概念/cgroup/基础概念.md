Linux Cgroups(Control groups) 是 Linux kernel 的一项功能：==它是在一个系统中运行的层级制进程组，你可对其进行资源分配==（如 CPU 时间、系统内存、网络带宽或者这些资源的组合）。通过使用 cgroup，==系统管理员在分配、排序、拒绝、管理和监控系统资源等方面，可以进行精细化控制。==硬件资源可以在应用程序和用户间智能分配，从而增加整体效率。


cgroup 和 `namespace` 类似，也是将进程进行分组，但它的目的和 `namespace` 不一样，`namespace` 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制

## 为什么需要 Cgroup

在 Linux 里，一直以来就有对进程进行分组的概念和需求，比如 [session group， progress group](https://icloudnative.io/go/?target=aHR0cHM6Ly93d3cud2luLnR1ZS5ubC9%2bYWViL2xpbnV4L2xrL2xrLTEwLmh0bWw%3d) 等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和 IO 使用情况等，于是出现了 cgroup，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等。

## 什么是Cgroup

==cgroup 是 Linux 下的一种将进程按组进行管理的机制==，在用户层看来，cgroup 技术就是把系统中的所有进程组织成一颗一颗独立的树，==每棵树都包含系统的所有进程==，树的每个节点是一个进程组，而每颗树又和一个或者多个 `subsystem` 关联，树的作用是将进程分组，而 `subsystem` 的作用就是对这些组进行操作。为了更好地理解这个概念，我们可以用一个类比来帮助理解.

首先，==cgroup 可以被理解为一个为进程 (程序的运行实例) 提供资源管理和限制的系统==。在这个系统中，有多个不同的 `subsystem` (子系统)，比如用于内存管理的 `memory` 子系统，用于 CPU 时间分配的 `cpu` 子系统等。每个子系统都负责管理系统的某个特定资源.

现在，我们可以将 `hierarchy` (层级) 想象成一个办公大楼，而每个 `subsystem` 则是大楼内的一个办公室。这个大楼 (`hierarchy`) 的设计是这样的

1. **每个办公室 (`subsystem`) 只能在一个大楼 (`hierarchy`) 中**。这就好比一个团队 (比如财务团队) 只能在一个办公大楼里有一个办公室。他们不能在两个不同的大楼里同时有办公室。
2. **同一个办公室 (`subsystem`) 不能同时在多个大楼 (`hierarchy`) 中**。这就像是说，财务团队不能同时在 “A 大楼” 和 “B 大楼” 里都有办公室

但是，不同的大楼可以有相同类型的办公室。例如，既可以在 “A 大楼” 也可以在 “B 大楼” 设有财务办公室，只不过这些办公室属于不同的团队。

在 cgroup 的上下文中，这意味着一个特定的 `subsystem` (比如内存管理) 可以在不同的 cgroup 层级中被配置和使用，但是在任何给定时间点，一个 `subsystem` 只能与一个 cgroup 层级相关联