锦恢、DBinary、invalid s 这些大佬都已经说的差不多了，我们从底层往上讨论，缕一缕。

0x01 中断
CPU 的架构一定会有一个机制，当外部或内部发生产生事件，通常导致正常执行代码被中止，而去执行其他的代码或控制其他电路，我们把整个流程，称之为中断（interrupt），当然，这个名词在不同的架构中细节含义不同，例如 arm 中，中断算作异常（exception）的一种。

而由于这个机制，发展出一些奇妙的东西。

0x02 并发与多线程
你写完的源代码，经过编译后会变成一个二进制文件，在 CPU 眼里这就是一个有许多指令组成的文本，CPU 只需按顺序去执行，不需要管其他的，遇到函数就会跳转。而 CPU 通常有一个系统定时器（system timer），于是就有人想到，我从源代码的角度，我分出两个无线循环的函数，利用这个定时器产生中断，每 1ms 我就切换一下，执行函数A里的指令后后1ms，切换到函数B里面，切换时把寄存器保存到 RAM 不就好了，这样从人的视角来看，就好像两个函数同时执行一样，我们把这种概念称之为并发（concurrency），把切换的过程称为上下文切换（context switch），于是人们利用系统定时器，专门写出来管理定时器的代码，即调度器（scheduler），再进一步发展出内核与操作系统，这时候诞生了任务、线程、进程的概念，从而基于并发给出了一个新名词，即多任务（multitasking），而任务在OS概念里是一个抽象词，在实际实现多以线程（threading）和进程（processing）的形式出现，进而出现多线程（multithreading）。

0x03 同步与异步 I/O
你写的代码可以让 CPU 去执行控制 I/O 的功能，我们可以不停的去访问 I/O 的状态，这个行为被称之为轮询 I/O（polling I/O）也叫同步 I/O（Synchronous I/O），另一种利用中断，让 I/O 去通知 CPU，这种行为被称之为中断 I/O，也叫异步 I/O（Asynchronous I/O），而这两种，又可以各自分阻塞（blocking）与非阻塞（none-blocking）。

![[Pasted image 20250926100035.png]]