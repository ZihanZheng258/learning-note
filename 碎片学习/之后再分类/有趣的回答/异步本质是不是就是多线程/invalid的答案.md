不是。Wikipedia对异步(Asynchronous, async)的定义是：
![[Pasted image 20250926095643.png]]

在计算机编程中，异步（Asynchrony）指的是事件独立于主程序流程发生，以及处理这类事件的方式。这些事件可能是 “外部” 事件，例如信号的到达，也可能是由程序发起、与程序执行同时进行的操作，且程序无需暂停等待结果。[1] 异步输入 / 输出（Asynchronous input/output）就是后者的一个例子，它允许程序向存储设备或网络设备发送指令，这些设备在处理请求时，处理器可以继续执行程序。这样做能在一定程度上实现并发。[1]

在编程接口中，处理异步的一种常见方式是提供子例程，这些子例程会返回一个 “未来”（future）或 “承诺”（promise），用于表示正在进行的操作；同时提供一个同步操作，该操作会阻塞，直到 “未来” 或 “承诺” 完成。有些编程语言（如 Cilk）拥有专门的语法来表达异步过程调用。[2]

异步的例子包括：

异步过程调用（Asynchronous procedure call）：一种并发运行过程的方法，是线程的轻量级替代方案。
Ajax：一套客户端 Web 技术，客户端可借助它创建异步 I/O Web 应用程序。
异步方法调度（Asynchronous method dispatch，简称 AMD）：一种数据通信方法，适用于服务器端需要处理大量长期客户端请求的场景。[3] 若使用同步方法调度（synchronous method dispatch，简称 SMD），这种场景可能会使服务器进入不可用的繁忙状态，进而因网络连接请求超时导致连接失败响应。采用异步方法调度时，客户端请求会立即被分配给线程池中的一个可用线程，而客户端则进入阻塞状态。任务完成后，服务器会通过回调得到通知，并解除客户端的阻塞状态，将响应回传给客户端。若出现线程饥饿（thread starvation），客户端会阻塞等待线程可用。

这个定义过于佶屈聱牙。

如果让我解释，那么“同步编程”就是“一整套系统好像齿轮紧密啮合一样，不允许出现任何错位/打滑之类状况”：

![[Pasted image 20250926095731.png]]

同步编程的好处是状态清晰、时序精准，如同齿轮啮合，因此好写、好测、好分析。坏处是整个系统必须一体联动，一旦某些东西无法如预期运行、或者从原理上就无法预期（比如你不可能知道网络带宽以及信道忙碌程度，以及服务器繁忙程度，也就无法保证某个调用一定会及时完成）。



而“异步编程（Asynchrony）”则类似汽车离合器，允许在此点断开连接、让两个或更多系统各自独立运行，直到再次连接：
![[Pasted image 20250926095758.png]]

异步状态复杂，时序混乱，难写难读难分析；但好处是允许几件事分头去干、互不影响——直到某个检查点需要检查、协调它们的状态。

因此，异步是自计算机诞生以来就必须考虑、必须解决的问题。

而要实现这个异步机制，我们有很多种技术思路，也有无数套不同的方案——在实践中，又有无数细节需要考量。



但，归根结底，计算机上的异步机制，本质上只有如下两种：

轮询
中断


当然，这两种太基本也太难用了，因此OS/各种编程基础库又搞了如下四类基础抽象：

多进程+进程间通讯：进程A和进程B自然可以各自独立运行；时不时通过消息同步下即可。
进程执行权由时间片控制；而时间片来自时钟中断。
多线程：不同线程自然可以各自独立运行；同步手法……随便。
os线程和进程类似；用户态线程由用户自己的信号控制
协程：协程是非抢夺式的线程。因为非强夺这个好处，因此它的同步较为简单。
协程不使用时间片机制，它的执行权需要自己主动出让。
各种语言提供的await/async等关键字往往关联协程（或者，干脆就是协程的对外接口）
消息/信号/锁：这个每个OS、每个库都有自己的实现，是个五花八门的大杂烩。但本质上，它们都是中断以及信号量等同步机制的衍生物。

当然，这两种太基本也太难用了，因此OS/各种编程基础库又搞了如下四类基础抽象：

多进程+进程间通讯：进程A和进程B自然可以各自独立运行；时不时通过消息同步下即可。
进程执行权由时间片控制；而时间片来自时钟中断。
多线程：不同线程自然可以各自独立运行；同步手法……随便。
os线程和进程类似；用户态线程由用户自己的信号控制
协程：协程是非抢夺式的线程。因为非强夺这个好处，因此它的同步较为简单。
协程不使用时间片机制，它的执行权需要自己主动出让。
各种语言提供的await/async等关键字往往关联协程（或者，干脆就是协程的对外接口）
消息/信号/锁：这个每个OS、每个库都有自己的实现，是个五花八门的大杂烩。但本质上，它们都是中断以及信号量等同步机制的衍生物。
注意：这个分类并不科学。其中进程、线程、协程算是分类，但消息/信号/锁却是（给进程/纤程/线程/协程以及其他需要使用的）同步机制。

事实上，被我放在下一层的select/poll也应该放在这层，作为os提供的接口来讨论的；但相比于赤裸裸的接口，select/poll里面又封装了一些机制（比如把锁等东西直接封装进去了）。因此我把它放在下一层讨论。



总之，上述四类基础抽象仍然不那么容易使用；因此在如上基础上，各家又有一大坨不同的抽象：

最通用最常见的抽象是select/poll系统调用
select/poll实质上是锁在文件这个抽象上面的封装
你可以把自己关心的各种文件，包括磁盘文件、socket文件以及其他文件放进select/poll调用
调用select/poll后，默认状况下，主进程陷入阻塞；直到你关注的所有文件里面有至少一个可读/可写
但你可以跟一个超时参数，使得select/poll提前返回（或者完全无阻塞，也就是把它当轮询用）
在互联网服务器这种一个程序同时服务几万人的场景下，select/poll表现不佳
于是Windows提供了iocp
而Linux则增加了一个epoll
Windows的iocp其实是一套新的框架，它结合了消息通知和线程池抽象
Linux的epoll则简陋的多
因为Windows的iocp和Linux的epoll都不好用；同时加上跨平台需求，就有人做了 一个库叫libevent
类似的库还有ACE，它的名气更大，但此库实践中很少有人用
有个调侃叫“学之者生，用之者死”
libevent几乎是事实上的网络编程标准，memcached、nginx、wireshark、lighttpd、redis、transmission、ntpd-rs等等知名项目都用它（或者曾经用过它）。
但是libevent仍然太复杂、太难理解；因此仍然有极多基于它的更高层封装和抽象
go等新兴语言甚至直接把异步模型做进自己的基础语言机制
再往下，封装就更多、更细致、更琐碎也更不知名了
比如说，如果你使用了RPC，那么这个RPC库（的server端）很可能就针对异步做了封装


总之，因为异步太过抽象、分层太多、层间关系过于混乱以及五花八门跨越不同层次的抽象实在太多太乱，使得几乎所有中级及以下程序员对它的理解都是错的（甚至大量高级程序员对它的理解也是错的——我甚至觉得实际情况应该是“绝大多数高级程序员的理解都是错的”）。

因此，各大公司/团队的高级程序员们不得不想方设法、到处拦截，绝不敢把异步相关的细节“漏”给水平不到的程序员。

至于题主的问题嘛……简单说，你的这个疑问，单进程单线程就能解决。怎么解决呢？自己去查select的接口说明以及相关例程。



不过，想要真正玩通这个，你最好学一学C/C++或者别的编译型语言（或者Java）。

当然其实各种脚本语言，比如python也可以直接用select：

毕竟，封装越接近底层、越接近底层就越容易，效果越好；越接近应用就越容易挂一漏万。遇到封装不及之处，还是得自己直接用裸的select等系统调用。

我用python写过网络应用，在我看来python对相关问题的支持非常好，完全没问题；但python之类脚本语言毕竟多了一层封装，使用os接口时往往需要来回打包解包，反而增加了复杂性，甚至可能会让没有c/c++等底层语言基础的朋友感到困惑。因此，或许初学者干脆自C、Rust、Java入手，路径反而会更清晰一些。