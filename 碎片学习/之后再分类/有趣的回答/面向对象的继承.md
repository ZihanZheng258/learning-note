1.
继承被新语言抛弃的原因是这玩意儿太强了, 经常会搞出出人意料的奇异现象, 人类把握不住.

比起继承带来的问题, 其好处直接被淹没了, 还不如用弱点的组合.

代码多写几行, 问题少亿点点.


含继承和子类型的语言里你要知道如下概念, 什么最小知识原则, 什么开闭原则, 什么里氏替换原则, 什么逆变协变双变抗变, 什么构造函数顺序地狱, 什么多的记不住的访问权限关键词, 什么多继承菱形继承虚基类, 什么 C3 线性化过程....

不过这些都是实践中的小小问题罢了, 花点心思总能解决.

致命问题是来自于整个子类型理论的, 92 年 Pierce 证明了有界量化不可判定[1], 基于 
 的语言傻了, 后面 Levy 和 Tiuryn 又独立证明了二阶类型不可判定[2], 基于 
 类型的语言也傻了, 学术型语言彻底放弃引入子类型, 而学术型语言正是工业型语言的风向标.
你路尽头都被这诡异的子类型污染了你还修个啥啊, 越修越诡异.

2.
面向对象继承派生都是为了设计规模宏大而复杂的程序的

但是后来人们发现程序的复杂度随规模指数上升，虽然面向对象还能支撑，但是人类智商已经驾驭不了这种复杂度了

于是人们开始从“如何开发大规模程序”转向了“如何不让程序规模太大”，把程序规模降下来，来适应人类的智商水平

如何限制程序的规模呢？取消继承就行了，用聚合组合之类的来代替，这样程序规模就大不起来了

程序规模越来越小，很多小型程序通过协议来组合成一个大的集群来完成任务

而那些不得不写得很大很复杂的程序呢？依然是面向对象派生继承，不信你看WebKit