## Count-Min Sketch 算法

刚才提到了LFU需要统计每个条数据的访问频率，这就需要一个int或者long类型来存储次数，但是仔细一想，一条缓存数据的访问次数真的需要int类型这么大的表示范围来统计吗？我们认为一个缓存被访问15次已经算是很高的频率了，==那么我们只用4个Bit就可以保存这个数据。（2^4=16）==

再来介绍一个cmSketch算法，看过硬核课堂BloomFilter视频的都知道，BloomFilter利用位图的思想来标记一条数据是否存在，存在与否可以用某个Bit位的0 | 1来代替，那么我们能不能扩展一下，利用这种思想来计数呢？

再来介绍一个cmSketch算法，看过硬核课堂BloomFilter视频的都知道，BloomFilter利用位图的思想来标记一条数据是否存在，存在与否可以用某个Bit位的0 | 1来代替，那么我们能不能扩展一下，利用这种思想来计数呢？

我们给要计数的值计算一个Hash，然后在位图中给这个Hash值对应的位置累加1就可以了，==但是BloomFilter中的一个典型问题是假阳性，可以说只要是用Hash计算就有存在冲突的可能==，那么cmSketch计数法如果出现冲突会怎么样呢？会给同一个位置多计算访问次数。这里cmSketch选择了以最小的统计数据值作为结果。这是一个不那么精确地统计方法，但是可以大致的反应访问分布的规律。


TinyLFU解决了LFU统计的内存消耗问题，和缓存保鲜的问题，但是TinyLFU是否还有缺点呢？

有，论文中是这么描述的，根据实测TinyLFU应对突发的稀疏流量时表现不佳。大概思考一下也可以得知，这些稀疏流量的访问频次不足以让他们在LFU缓存中占据位置，很快就又被淘汰了。

我们回顾之前讲过的，LRU对于稀疏流量效果很好，那可以不可以把LRU和LFU结合一下呢？就出现了下面这种缓存策略。

## 三、Window-TinyLFU

Window-TinyLFU策略里包含LRU和LFU两部分，前端的小LRU叫做Window LRU，它的容量只占据1%的总空间，它的目的就是用来存放短期的突发访问数据。存放主要元素的Segmented LRU(SLRU)是一种LRU的改进，主要把在一个时间窗口内命中至少2次的记录和命中1次的单独存放，这样就可以把短期内较频繁的缓存元素区分开来。具体做法上，SLRU包含2个固定尺寸的LRU，一个叫Probation段A1，一个叫Protection段A2。新记录总是插入到A1中，当A1的记录被再次访问，就把它移到A2，当A2满了需要驱逐记录时，会把驱逐记录插入到A1中。W-TinyLFU中，SLRU有80%空间被分配给A2段