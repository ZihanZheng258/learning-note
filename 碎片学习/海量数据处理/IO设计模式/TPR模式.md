传统的 Server/Client 模式会基于**TPR（Thread per Request）**,服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。

![[Pasted image 20250603171644.png]]

这种模式虽然处理起来简单方便，==但是由于服务器为每个 client 的连接都采用一个线程去处理，使得资源占用非常大==。当客户端多时，会创建大量的处理线程。==且每个线程都要占用栈空间和一些CPU 时间；另外，阻塞可能带来频繁的上下文切换==，且大部分上下文切换可能是无意义的。所以服务器会增加很多没必要的开销。

因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，==也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理==，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。

但是线程池也有它的弊端，==如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理==，就会导致客户端连接失败，从而影响用户体验。假如线程池中有200个线程，而有200个用户都在进行大文件下载，会导致第201个用户的请求无法及时处理，即便第201个用户只想请求一个几KB大小的页面。。。因此，线程池比较适合大量的短连接应用。

因此便出现了下面的两种高性能 IO 设计模式：Reactor 和 Proactor。