Reactor 和 Proactor 都是处理并发 I/O（输入/输出）操作的设计模式，特别是在网络编程中非常常见。==它们的主要区别在于如何处理 I/O 操作的事件以及与操作系统交互的方式，可以简单地理解为同步非阻塞和异步非阻塞的模式。==

---

### Reactor 模式（同步非阻塞）

**工作原理：**

想象一个电话接线员。这个接线员（**Reactor**）的任务是监听很多部电话，但她不直接接听电话并与人交谈。她的职责是：

1. **等待事件发生：** 她持续监听所有电话线，看是否有电话响（**I/O 就绪事件**）。
    
2. **事件多路分解（Demultiplexing）：** 一旦某部电话响了，她会识别出是哪部电话，并将其分配给一个空闲的同事（**事件处理器 Handler**）。
    
3. **分派处理：** 她将这个电话（连接）交给处理事件的同事。
    
4. **同步执行：** 此时，这位同事（Handler）会亲自拿起电话，进行实际的通话（执行 I/O 操作，比如读取或写入数据）。在通话过程中，==同事需要自己处理整个过程，并且这个过程是同步的，**在完成之前会阻塞这个特定的处理线程**。==
    

**关键特点：**

- **同步 I/O：** I/O 操作由应用程序本身在事件就绪后同步执行。
    
- **事件类型：** ==监听的是“**I/O 就绪**”事件，比如“套接字可读”或“套接字可写”。==
    
- **依赖：** 依赖于操作系统的 I/O 多路复用机制，例如 Linux 的 `epoll`、BSD 的 `kqueue`、Windows 的 `select`/`poll`。这些机制只通知你“有数据了”，但数据需要你自己去读。
    

**优点：**

- **实现相对简单：** 模型直观，容易理解和实现。
    
- **跨平台性好：** 许多操作系统都提供了类似的 I/O 多路复用接口。
    

**缺点：**

- **处理长耗时任务时会阻塞：** ==如果某个事件处理器（Handler）执行了一个非常耗时或阻塞的操作，它会阻塞整个事件循环，导致其他事件无法及时处理。==
    

---

### Proactor 模式（异步非阻塞）

**工作原理：**

继续用电话接线员的例子。现在，接线员（**Proactor**）的角色发生了变化。

1. **主动发起请求：** 你（应用程序）不是等着电话响，而是直接对接线员说：“嘿，帮我接听这个电话，等有数据了直接读到这个缓冲区里，然后把结果告诉我。==”这个过程就是**发起一个异步 I/O 操作**。==
    
2. **操作系统执行：** 接线员（Proactor）将这个任务（异步 I/O）交给一个专门的团队，也就是**操作系统内核**。
    
3. **等待完成事件：** 应用程序在发起请求后立即返回，可以继续做其他事情，不需要等待。
    
4. **通知完成：** 当操作系统完成了读写操作后，它会通知 Proactor，而不是通知“数据就绪”。这个通知是一个“**I/O 完成**”事件。
    
5. **分派完成事件：** Proactor 收到完成通知后，==将结果和关联的“回调函数”（**Completion Handler**）分派给事件处理器。==
    
6. **执行回调：** 事件处理器直接处理已经完成的结果，无需再进行阻塞的 I/O 操作。
    

**关键特点：**

- **异步 I/O：** I/O 操作本身由操作系统或其他线程在后台完成，应用程序只在操作完成后接收通知。
    
- **事件类型：** 监听的是“**I/O 完成**”事件，比如“读取操作已完成”或“写入操作已完成”。
    
- **依赖：** 依赖于操作系统的异步 I/O 支持，如 Windows 的 I/O Completion Port (IOCP)。
    

**优点：**

- **高并发和高性能：** 应用程序线程完全不被 I/O 操作阻塞，可以充分利用 CPU 资源，特别适合处理大量长耗时 I/O 任务。
    
- **简化编程：** 应用程序无需自行管理缓冲区或处理读写就绪状态，只需提供一个回调函数来处理结果。
    

**缺点：**

- **实现复杂：** 模型更复杂，调试难度也更高。
    
- **依赖操作系统支持：** Proactor 模式的效率高度依赖底层操作系统的异步 I/O 支持。在某些系统（如早期的 Unix）上，这种支持并不完善或高效。
    

### 总结

|特性|Reactor 模式|Proactor 模式|
|---|---|---|
|**I/O 模型**|==同步非阻塞==|==异步非阻塞==|
|**事件类型**|I/O **就绪**事件（例如：套接字可读）|I/O **完成**事件（例如：读取操作已完成）|
|**谁执行 I/O**|应用程序（在事件就绪后）|操作系统或后台线程|
|**优点**|实现简单，跨平台性好|高性能、高并发，应用线程不阻塞|
|**缺点**|处理长耗时任务时可能阻塞整个事件循环|实现复杂，高度依赖操作系统原生支持|

导出到 Google 表格

**何时使用？**

- 如果你主要处理 **I/O 密集型**任务，并且需要极致的性能和并发，同时你的平台提供了强大的异步 I/O 支持（如 Windows），那么 **Proactor** 模式是更好的选择。
    
- 如果你需要在不同平台之间保持一致性，或者处理的任务相对轻量，不至于长时间阻塞，那么 **Reactor** 模式是一个更通用的、容易实现的解决方案。许多现代框架（如 Node.js 的 libuv）虽然用的是 Reactor 模型，但内部通过线程池等方式模拟了异步操作，从而规避了长时间阻塞的问题。