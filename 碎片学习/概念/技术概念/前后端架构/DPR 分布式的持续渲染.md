DPR的运行模式如下

1. 去除了 fallback 行为==，而是直接用 On-demand Builder（按需构建器）来响应未经过预渲染的页面，然后将结果缓存至 CDN；==
2. 数据页面过期时，不再响应过期的缓存页面，而是 CDN 回源到 Builder 上，渲染出最新的数据；
3. 每次发布新版本时，自动清除 CDN 的缓存数据。

### DPR的缺点
1. 新页面的访问可能会触发 On-demand Builder 同步渲染，导致当次请求的响应时间比较长；
2. 比较难防御 DoS 攻击，因为攻击者可能会大量访问新页面，导致 Builder 被大量并行地运行，这里需要平台方实现 Builder 的归一化和串行运行