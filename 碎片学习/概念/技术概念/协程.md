#### **什么是协程**

我们可以简单的认为：[协程](https://so.csdn.net/so/search?q=%E5%8D%8F%E7%A8%8B&spm=1001.2101.3001.7020)就是用户态的线程，但是上下文切换的时机是靠调用方（写代码的开发人员）自身去控制的。

协程不是[进程](https://zhida.zhihu.com/search?content_id=187417878&content_type=Article&match_order=1&q=%E8%BF%9B%E7%A8%8B&zhida_source=entity)，也不是[线程](https://zhida.zhihu.com/search?content_id=187417878&content_type=Article&match_order=1&q=%E7%BA%BF%E7%A8%8B&zhida_source=entity)，它就是一个函数，一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。所以说，协程与进程、线程相比，不是一个维度的概念。

协程函数与普通函数的区别：普通函数执行完返回，则结束，协程函数可以运行到一半，返回并保留上下文；下次唤醒时恢复上下文，可以接着执行。

同时，协程和用户态线程非常接近，用户态线程之间的切换不需要陷入内核，但部分操作系统中用户态线程的切换需要内核态线程的辅助。

下面是C++例子

``` C++
void A() {
   cout << 1 << " ";
   cout << 2 << " ";
   cout << 3 << " ";
}
 
void B() {
   cout << "x" << " ";
   cout << "y" << " ";
   cout << "z" << " ";
}
 
int main(void) {
  A();
  B();
```

``` C++
void A() {
   cout << 1 << " ";
   cout << 2 << " ";
   co_yield_ct();  // 切出到主协程
   cout << 3 << " ";
}
 
void B() {
   cout << "x" << " ";
   co_yield_ct();  // 切出到主协程
   cout << "y" << " ";
   cout << "z" << " ";
}
 
int main(void) {
  ...  // 主协程
  co_resume(A);  // 启动协程 A
  co_resume(B);  // 启动协程 B
  co_resume(A);  // 从协程 A 切出处继续执行
  co_resume(B);  // 从协程 B 切出处继续执行
}
```