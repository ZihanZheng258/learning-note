钟表和计算机内部都有一个叫做「晶体振荡器」的东西，给它加上电压，它就会以固定的频率振动。但这个振动频率的「稳定性」，取决于它的制造工艺，以及外界环境的影响。

出于成本的考虑，钟表的制作工艺没那么高，==所以它更容易有误差。而电脑制造工艺虽然比较高，但它内部的晶体振荡器也会受到「温度」变化带来的影响==，在工作过程中，也会有产生误差。

# 一秒到底有多长？
一直以来，我们对于「秒」的定义需求，从本质上讲，就是想要一个「完全稳定」的周期，也就是说，期望每一秒都是固定「等长」的。

那在微观世界层面，是否存在一种元素，它的运动周期是「高度稳定」，不受外界环境影响的呢？

每个原子都有一个原子核，核外分层排布着高速运转的电子，当原子受电磁辐射时，它的轨道电子可以从一个位置「跳」到另一个位置，物理学上称此为「跃迁」。

人们发现，原子内的电子发生跃迁时，原子会吸收或放出一定能量的「电磁波」，这类电磁波就是一种「周期运动」，我们也可以把它看成原子内部的「振荡」

终于，科学家们发现确实存在这样一种原子：**铯原子**，它内部的振荡周期比其它原子都要**更短、更稳定**，而且，这个过程基本不受环境因素的干扰。

之后，科学家们就以之前定义的「秒」为基础，去测量一秒内这个铯原子内部电子周期运动的「次数」，测量出来的结果为 9192631770 次（91 亿+次）

基于此，科学家们决定「抛弃」原来基于天文测量的秒，重新定义「秒」的时长，就是这个高度稳定的运动周期。

有了原子钟，**人们基于原子钟又确立了一套新的时间标准，叫做「国际原子时」（International Atomic Time，简称 TAI）**。

## 闰秒
因为原子时非常稳定，但世界时随着地球自转变慢，会越来越慢，就会发生这种现象：

- 原子时走得快，世界时走得慢，时间越久，两者差距越来越大
- 日复一日，几百年后，世界时的正午 12 点是太阳高照的时刻，而原子时可能已经走到了下午 2 点了
- 几千年后，太阳高照的时刻，原子时可能已经走到了**晚上 8 点**！

我们可以再建立一套「新的时间标准」，这套时间以「原子时为基准」，开始计时，走的每一秒都是稳定、精确的。

同时，为了兼顾基于天文测量的世界时，人类会「持续观测」世界时与这个新时钟的差距。

如果发现两者相差过大时，我们就「人为」地调整一下这个时钟（加一秒或减一秒），让两者相差不超过 0.9 秒。

例如，这个时钟本身比世界时走得快，经过一段时间后，如果发现两者相差越来越大，那就给这个时钟「加一秒」，让这个时钟在 23:59:59 的下一秒变为 23:59:60 秒，让它与世界时差距控制在 0.9 秒以内。这一秒被称之为闰秒

> 当然，当地球自转速度变快时，这里也有可能是减一秒，即从 23:59:58 直接跳到 00:00:00。  
> 但这种情况比较少，大部分情况下，地球自转速度是越来越慢的。
> 
> 目前，全球已累计加过 27 次闰秒，最近一次闰秒调整，是在北京时间 2017 年 1 月 1 日的 07:59:59 变为 07:59:60 秒。

## 授时

到现在我们知道，世界标准时间和北京时间是怎么来的，但北京时间的产生是在陕西省，难道校准一次时间需要跑到这里吗？

很显然是不需要的。

位于陕西省的中国科学院国家授时中心，产生北京时间后，会通过一系列方式，把这个时间广播出去，这个过程，就叫做「授时」。

国家授时中心提供很多授时方式，例如**无线电波、网络、电话**，都可以把时间广播出去。

通常来说，无线电波的传播速度更快、传播误差小，所以授时中心会通过这种方式，把时间发送给全国各地的「时间服务器」。

## 主机同步时间

如果你了解一些运维相关的工作，就会知道，我们部署应用程序的服务器上，都会启动一个「自动校准」时间的服务，这个服务就是 NTP（Network Time Protocol），它可以保证每台机器的时间与时间服务器保持同步。

那 NTP 是怎么同步服务器时间的呢？

这里就涉及到 2 个重点：

1. NTP 如何同步时间？
2. 同步时间时，对正在运行的程序有没有影响？

先来看第一个问题：**NTP 如何同步时间？**

简单来讲，它是通过在网络报文上打「时间戳」的方式，然后配合计算网络延迟，从而修正本机的时间。

这样一来，客户端就可以「校准」自己的本机时间了，与服务端保持同步，这个时间误差在广域网下是 10ms - 500ms，在局域网下通常可以小于 1ms。

再来看第二个问题：**同步时间时，对正在运行的程序有没有影响？**

这里就牵涉出 2 个概念：墙上时钟、单调时钟，它们之间有什么区别呢？

- **墙上时钟**：通常就是指前面讲到的协调世界时 UTC，校准时间后，可能发生回拨
- **单调时钟**：计算机自启动以后经历的纳秒数，不会回拨

一般我们写的代码，像上面程序调用的「时间 API」，通常获取的时间是**墙上时钟**，所以，如果时间发生校准，就可能会发生「时光倒流」的情况。

这必然对程序产生很大的影响，怎么解决这个问题呢？

幸运的是，NTP 在校准时间时，提供了 2 种方式：

1. **ntpdate**：一切以服务端时间为准，「强制修改」本机时间
2. **ntpd**：采用「润物细无声」的方式修改本机时间，把时间差均摊到每次小的调整上

也就是说，ntpd 当接收到需要「回拨」的时间时，会让本机时间走得「慢」一点，小步调整，逐渐与服务端的时钟「对齐」，这样一来，本机时间依旧是递增的，避免发生「倒流」。

当我们在配置 ntp 服务时，需要格外注意这种情况。另外，在编写程序时，也要注意调用的时间 API 获取的是哪个时间，避免业务逻辑发生异常。