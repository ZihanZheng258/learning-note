逆变（Contravariance）、协变（Covariance）和双变（Bivariance）、抗变（Invariance）==是理解面向对象语言中**类型系统**和**泛型**的关键概念。它们描述了当类型之间存在父子关系时，包含这些类型的“容器”或“函数”之间是怎样的关系。==

我们可以用一个简单的例子来解释：

- **父类**：`Animal`
    
- **子类**：`Dog`，它继承自 `Animal`
    

现在我们来解释这四种“变”：

### 1. 协变 (Covariance)

协变指的是，如果 `Dog` 是 `Animal` 的子类型，那么一个包含 `Dog` 的容器或函数，可以被看作是包含 `Animal` 的容器或函数的子类型。

**核心思想：子类型可以替代父类型。**

- **直观理解**：一个装满 `Dog` 的笼子，可以被视为一个装满 `Animal` 的笼子。
    
- **例子**：
    
    - `List<Dog>` **可以**赋值给 `List<Animal>`。
        
    - 一个返回 `Dog` 的方法，可以被用在需要返回 `Animal` 的地方。
        

**应用**：Java 中的数组就是协变的。`Dog[]` 是 `Animal[]` 的子类型。然而，这可能会导致运行时错误，==比如你向 `Animal[]` 数组中放入一个 `Cat`，但这个数组实际上是 `Dog[]`==。

### 2. 逆变 (Contravariance)

逆变与协变正好相反。如果 `Dog` 是 `Animal` 的子类型，那么一个接受 `Animal` 作为参数的函数，可以被看作是接受 `Dog` 作为参数的函数的子类型。

**核心思想：父类型可以替代子类型。**

- **直观理解**：一个能吃任何 `Animal` 的函数（如 `feed(Animal a)`），可以被看作是一个能吃 `Dog` 的函数。因为如果它能吃 `Animal`，那当然也能吃 `Dog`。
    
- **例子**：
    
    - 一个消费者函数 `Consumer<Animal>` **可以**赋值给 `Consumer<Dog>`。
        

**应用**：Java 的 `Consumer` 和 `Comparator` 接口就是逆变的。==例如，`Comparator<Animal>` 可以用于比较 `Dog` 对象，因为它能处理更通用的 `Animal` 类型。==

### 3. 抗变（不变） (Invariance)

抗变是最严格的，它指的是，即使 `Dog` 是 `Animal` 的子类型，一个包含 `Dog` 的容器或函数，==也不能被看作是包含 `Animal` 的容器或函数的子类型，反之亦然。==

**核心思想：类型必须完全匹配。**

- **直观理解**：一个装满 `Dog` 的笼子，**不能**被视为一个装满 `Animal` 的笼子，反之亦然。它们是两种完全独立的类型。
    
- **例子**：
    
    - 在 Java 泛型中，`List<Dog>` **不能**赋值给 `List<Animal>`。这是为了防止运行时类型安全问题。
        

**应用**：大多数泛型类型，如 Java 中的 `List<T>`、C++ 中的 `std::vector<T>`，默认都是抗变的，以确保类型安全。

### 4. 双变 (Bivariance)

双变指的是，一个类型既可以被看作是协变的，也可以被看作是逆变的。这意味着它既可以**接受**父类型作为子类型，也可以**被**子类型替代。

**核心思想：通吃，不挑类型。**

- **直观理解**：一种神奇的笼子，既能装任何 `Animal`，也能被看作是装 `Dog` 的笼子。这通常会导致类型安全问题。
    
- **例子**：TypeScript 中的函数类型默认就是双变的。`function f(x: Dog) {}` 可以赋值给 `function g(x: Animal) {}`，这在某些情况下是不安全的。


![[Pasted image 20250909142652.png]]