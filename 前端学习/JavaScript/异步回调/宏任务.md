
在 JavaScript 中，**宏任务**是事件循环（Event Loop）机制中的一个核心概念。为了避免长时间运行的代码阻塞主线程（即用户界面卡死），==浏览器或 Node.js 环境将任务划分为两大类：**宏任务 (Macrotasks)** 和 **微任务 (Microtasks)**。==

### 宏任务的原理

你可以把事件循环想象成一个流水线，==**宏任务**就是流水线上**一个个完整的、独立的“大工作包”**。==

1. **初始启动**：当你运行一段 JavaScript 代码时，整个 `<script>` 标签内的代码块本身被视为一个最大的宏任务，它会在主线程上立即执行。
    
2. **加入队列**：当主线程执行过程中，遇到特定的异步操作时，这些操作的回调函数会被推送到一个专门的 ==**宏任务队列 (Macrotask Queue)** 中排队等待。==
    
3. **循环检查**：当主线程执行完当前的宏任务（即主线程上的代码全部执行完毕，包括所有同步代码和微任务）后==，事件循环会检查宏任务队列。==
    
4. **取出执行**：如果队列中有任务，事件循环会**从中取出一个宏任务**，将其放入主线程执行。
    
5. **清空微任务**：**重点来了**：在执行完这个宏任务之后，事件循环会立即去检查并**清空所有微任务队列**，然后再开始下一轮的宏任务。

### 常见的宏任务来源

- **`setTimeout()` 和 `setInterval()`**：==最常见的宏任务。它们的回调函数在设定的延迟时间后，会被加入宏任务队列==。
    
- **I/O 操作**：包括文件读写、网络请求回调（在浏览器中通常是微任务，但在 Node.js 中，像文件操作等 I/O 相关的回调通常是宏任务）。
    
- **用户交互事件**：比如 `click`、`scroll` 等事件的处理函数。
    
- **`requestAnimationFrame()`**：用于动画的 API，它也是一个特殊的宏任务。
-
- 用户交互事件：例如点击、滚动、键盘输入等用户操作触发的事件。
-
- 定时器（Timers）：使用 `setTimeout`、`setInterval`、`setImmediate` 等创建的定时器任务。
-
- 网络请求与服务器响应：例如通过 AJAX、fetch 或 WebSocket 发起的网络请求和相应的回调函数。
-
- 文件操作：例如读取文件或写入文件的操作。
-
- 页面渲染（Rendering）：浏览器渲染引擎对 DOM 的布局和绘制操作。
-
- JavaScript 脚本执行：包括全局代码、函数调用、事件处理函数等。

## 宏任务、微任务与事件循环的执行顺序

要真正理解宏任务，必须将它与微任务放在一起看。执行顺序是严格且固定的：

1. **执行当前宏任务**：执行主线程上的同步代码。
    
2. **清空微任务队列**：==同步代码执行完毕后，立即执行所有排队等待的微任务==（如 **`Promise.then()`** 和 **`async/await`** 中的 `await` 之后的部分）。
    
3. **进入下一轮循环**：微任务清空后，当前宏任务才算真正结束。
    
4. **取出下一个宏任务**：事件循环从宏任务队列中取出一个新的宏任务并执行（回到第 1 步）。

总结：==每一次宏任务的执行，都会伴随着一次微任务队列的完全清空。==


