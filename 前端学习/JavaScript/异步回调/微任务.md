好的，我们来详细讲解 **JavaScript 微任务 (Microtasks)** 的原理，它是理解 JavaScript **事件循环 (Event Loop)** 机制中，比宏任务更优先、更精细的任务类型。

## JavaScript 微任务 (Microtasks) 原理解析

微任务是事件循环中一个**高优先级**的任务队列。它的设计是为了处理那些需要立即执行、==不希望被浏览器渲染或用户交互等宏任务打断的异步操作。==

### 核心原理：高优先级和“插队”

微任务的关键在于它的执行时机：它是在 **当前宏任务执行完毕之后，下一轮宏任务开始之前** 立即执行，==并且会一次性**清空整个队列**。==

你可以把事件循环想象成一个循环：

1. **宏任务执行**：主线程执行一个宏任务（比如整个 `<script>` 代码块）。
    
2. **微任务“插队”**：在宏任务执行过程中，遇到的微任务会被推入微任务队列。
    
3. **清空微任务**：当宏任务执行完毕后，事件循环不会立即开始下一个宏任务，==而是**暂停**，转而检查并执行微任务队列中的所有任务。==
    
4. **循环继续**：只有当微任务队列彻底清空后，事件循环才会从宏任务队列中取出下一个任务执行。
    

这种机制保证了微任务比宏任务具有更高的优先级，能够更快地得到响应。

### 常见的微任务来源

- **`Promise.then()`、`.catch()`、`.finally()`**：==Promise 状态改变后，注册的回调函数会被推入微任务队列。这是最常见且最核心的微任务来源。==
    
- **`async/await`**：`await` 关键字后面的代码实际上会被编译成 Promise 的 `then` 回调，因此它也是微任务。
    
- **`queueMicrotask()`**：一个专门用于调度微任务的 API。
    
- **`MutationObserver`**：用于监听 DOM 变化的回调函数。