好的，我们来详细聊聊 JavaScript 中的**堆 (Heap)** 和**栈 (Stack)**。理解这两个内存区域对于理解 JavaScript 的性能和变量的生命周期至关重要。

---

## 堆（Heap）和栈（Stack）是什么？

在 JavaScript 运行时环境中，==**堆**和**栈**是两个主要的内存区域，它们用于存储不同类型的数据，并且工作方式也完全不同。==

### 1. 栈（Stack）

**栈**是一种**后进先出 (LIFO - Last-In, First-Out)** 的数据结构，就像一叠盘子。

|特性|描述|
|---|---|
|**存储内容**|存储**原始类型的值**（Primitive Values）和**执行上下文**（Execution Contexts）。|
|**原始类型**|包括：`Number`（数字）、`String`（字符串）、`Boolean`（布尔值）、`Null`、`Undefined`、`Symbol`、`BigInt`。这些值直接存储在栈中。|
|**执行上下文**|每次调用函数时，都会创建一个新的**栈帧**（Stack Frame）并压入栈中。这个栈帧包含了函数执行所需的所有信息，包括它的局部变量。|
|**工作方式**|**分配和回收速度极快。** 当函数调用结束时，整个栈帧会被立即弹出和销毁。|
|**内存大小**|内存空间相对较小且固|
### 2. 堆（Heap）

**堆**是一个**非结构化**的、**动态分配**的内存区域。

| 特性       | 描述                                                                  |
| -------- | ------------------------------------------------------------------- |
| **存储内容** | 存储**引用类型的值**（Reference Values）。                                     |
| **引用类型** | 包括：`Object`（对象）、`Array`（数组）、`Function`（函数）等。这些值的大小是动态变化的，不能固定分配在栈上。 |
| **工作方式** | 内存的分配是动态的，通常比栈慢。堆内存的回收由 **垃圾回收器 (Garbage Collector)** 负责，而不是简单的弹出。  |
| **引用关系** | 存储在堆中的实际对象，其**内存地址**（即引用）会存储在栈中，作为变量的值。                             |
| **内存大小** | 内存空间较大且灵活，只受限于系统内存。                                                 |

导出到 Google 表格

**简而言之：** 堆是 JavaScript 引擎用来**灵活**、**动态**地存储**大而复杂**数据的区域。

## 堆与栈如何协同工作？（以变量存储为例）

当你在 JavaScript 中声明一个变量时，==它存储在堆还是栈中，取决于它的数据类型：==

### 示例 1：原始类型（栈）

JavaScript

```
let count = 100;
```

1. **变量名 `count`** 和 **值 `100`** 都存储在**栈**上。
    

### 示例 2：引用类型（堆和栈协同）

JavaScript

```
let person = { name: "Alice", age: 30 };
```

1. **对象值** `{ name: "Alice", age: 30 }` 作为一个整体存储在**堆**上的某个内存地址（比如 `0x00A1`）。
    
2. **变量名 `person`** 和 **地址引用 `0x00A1`** 存储在**栈**上。
    
3. 当你通过 `person` 访问对象时，JS 引擎会先从栈中取出地址 `0x00A1`，再根据这个地址去堆中找到实际的对象。
    

### 示例 3：闭包与堆内存的延长生命周期

回顾我们之前讨论的闭包：

JavaScript

```
function create() {
  let count = 0; // 局部变量
  return () => count++;
}
const closureFn = create();
```

1. 当 `create` 函数执行时，局部变量 `count` **原本**应该在栈上。
    
2. 但因为它被返回的函数（闭包）引用，JS 引擎会发现它需要“活”得更久。
    
3. **提升（Hoisting）**==：JS 引擎会将 `count` 的值提升到**堆内存**中存储。==
    
4. **栈中保存引用**：==`closureFn` 变量（在栈上）保存着对这个堆中 `count` 变量的引用。==
    
5. **GC 豁免**：只要 `closureFn` 存活，堆中的 `count` 变量就不会被垃圾回收器清理，从而实现了**生命周期的延长**。

这就是堆和栈在 JavaScript 中协同工作的基本模式，它决定了数据存储的位置、访问速度以及变量的生命周期管理。