随着我们的应用越来越大，我们想要将其拆分成多个文件，即所谓的“模块（module）”。一个模块可以包含用于特定目的的类或函数库。

很长一段时间，JavaScript 都没有语言级（language-level）的模块语法。这不是一个问题，因为最初的脚本又小又简单，所以没必要将其模块化。

但是最终脚本变得越来越复杂，因此社区发明了许多种方法来将代码组织到模块中，使用特殊的库按需加载模块。

## [什么是模块？](https://zh.javascript.info/modules-intro#shen-me-shi-mo-kuai)

一个模块（module）就是一个文件。一个脚本就是一个模块。就这么简单。

==模块可以相互加载，并可以使用特殊的指令 `export` 和 `import` 来交换功能，从另一个模块调用一个模块的函数==：

- `export` 关键字标记了可以从当前模块外部访问的变量和函数。
- `import` 关键字允许从其他模块导入功能。

```js
// 📁 sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
```

```js
// 📁 main.js
import { sayHi } from './sayHi.js';

alert(sayHi); // function...
sayHi('John'); // Hello, John!
```

==`import` 指令通过相对于当前文件的路径 `./sayHi.js` 加载模块，并将导入的函数 `sayHi` 分配（assign）给相应的变量。==

让我们在浏览器中运行一下这个示例。

由于模块支持特殊的关键字和功能，因此我们必须通过使用 `<script type="module">` 特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。

## [模块核心功能](https://zh.javascript.info/modules-intro#mo-kuai-he-xin-gong-neng)

与“常规”脚本相比，模块有什么不同呢？
下面是一些核心的功能，对浏览器和服务端的 JavaScript 来说都有效。

### [始终使用 “use strict”](https://zh.javascript.info/modules-intro#shi-zhong-shi-yong-usestrict)

模块始终在严格模式下运行。例如，对一个未声明的变量赋值将产生错误（译注：在浏览器控制台可以看到 error 信息）。

```js
<script type="module">
  a = 5; // error
</script>
```

### [模块级作用域](https://zh.javascript.info/modules-intro#mo-kuai-ji-zuo-yong-yu)

每个模块都有自己的顶级作用域（top-level scope）。换句话说，==一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。==

在下面这个例子中，我们导入了两个脚本，`hello.js` 尝试使用在 `user.js` 中声明的变量 `user`。它失败了，因为它是一个单独的模块（你在控制台中可以看到报错）：

模块应该 `export` 它们想要被外部访问的内容，并 `import` 它们所需要的内容。

- `user.js` 应该导出 `user` 变量。
- `hello.js` 应该从 `user.js` 模块中导入它。

==在浏览器中，对于 HTML 页面，每个 `<script type="module">` 都存在独立的顶级作用域。==

### [模块代码仅在第一次导入时被解析](https://zh.javascript.info/modules-intro#mo-kuai-dai-ma-jin-zai-di-yi-ci-dao-ru-shi-bei-jie-xi)

如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入时。然后将其导出（export）的内容提供给进一步的导入（importer）。

首先，如果执行一个模块中的代码会带来副作用（side-effect），例如显示一条消息，那么多次导入它只会触发一次显示 —— 即第一次：

```js
// 📁 alert.js
alert("Module is evaluated!");
```

```js
// 在不同的文件中导入相同的模块

// 📁 1.js
import `./alert.js`; // Module is evaluated!

// 📁 2.js
import `./alert.js`; // (什么都不显示)
```

第二次导入什么也没显示，因为模块已经执行过了。

现在，让我们看一个更复杂的例子。
我们假设一个模块导出了一个对象：

```js
// 📁 admin.js
export let admin = {
  name: "John"
};
```

如果这个模块被导入到多个文件中，==模块仅在第一次被导入时被解析，并创建 `admin` 对象，然后将其传入到所有的导入。==

所有的导入都只获得了一个唯一的 `admin` 对象：

``` js
// 📁 1.js
import { admin } from './admin.js';
admin.name = "Pete";

// 📁 2.js
import { admin } from './admin.js';
alert(admin.name); // Pete

// 1.js 和 2.js 引用的是同一个 admin 对象
// 在 1.js 中对对象做的更改，在 2.js 中也是可见的
```

正如你所看到的，当在 `1.js` 中修改了导入的 `admin` 中的 `name` 属性时，我们在 `2.js` 中可以看到新的 `admin.name`。

==这正是因为该模块只执行了一次==。生成导出，然后这些导出在导入之间共享，因此如果更改了 `admin` 对象，在其他导入中也会看到。

**这种行为实际上非常方便，因为它允许我们“配置”模块。**

换句话说，模块可以提供需要配置的通用功能。例如身份验证需要凭证。==那么模块可以导出一个配置对象，期望外部代码可以对其进行赋值。==

这是经典的使用模式：

1. 模块导出一些配置方法，例如一个配置对象。
2. 在第一次导入时，我们对其进行初始化，写入其属性。可以在应用顶级脚本中进行此操作。
3. 进一步地导入使用模块。

例如，`admin.js` 模块可能提供了某些功能（例如身份验证），但希望凭证可以从模块之外赋值到 `config` 对象：

```js
// 📁 admin.js
export let config = { };

export function sayHi() {
  alert(`Ready to serve, ${config.user}!`);
}
```

这里，admin.js 导出了 config 对象（最初是空的，但也可能有默认属性）。

然后，在 ==init.js 中，我们应用的第一个脚本，我们从 init.js 导入了 config 并设置了 config.user：==

```js
// 📁 init.js
import { config } from './admin.js';
config.user = "Pete";
```

……现在模块 `admin.js` 已经是被配置过的了。
其他导入可以调用它，它会正确显示当前用户：

```js
// 📁 another.js
import { sayHi } from './admin.js';
sayHi(); // Ready to serve, Pete!
```

