**MI 全称是 Remote Method Invocation (远程方法调用)**。它是一个 Java API，==允许一个 Java 虚拟机 (JVM) 中的对象调用另一个不同 JVM 中的对象的方法==。这些不同的 JVM 可以位于同一台机器上，也可以位于不同的机器上（通过网络连接）。

简单来说，RMI 使得编写分布式 Java 应用程序变得可能，让你可以像调用本地对象方法一样，透明地调用远程对象的方法。

### RMI 的核心概念和工作原理：

1. **分布式应用：** RMI 主要用于构建分布式应用程序，这意味着应用程序的不同部分可以在不同的计算机上运行，并通过网络进行通信。
    
2. **远程对象：** 要被远程调用的对象被称为“远程对象”。这些对象必须实现一个继承自 `java.rmi.Remote` 接口的接口，并且该接口中所有可远程调用的方法都必须抛出 `java.rmi.RemoteException`。
    
3. **客户端-服务器模型：** RMI 通常采用客户端-服务器模型。
    
    - **服务器端：** ==创建远程对象，并将其注册到一个 RMI 注册表（RMI Registry）==中，以便客户端能够查找并访问它们。
    - **客户端：** ==通过 RMI 注册表查找远程对象的引用，然后像调用本地对象一样调用其方法。==
4. **Stub (存根) 和 Skeleton (骨架)：**
    
    - **Stub (客户端存根)：** 位于客户端。它是远程对象的一个本地代理。当客户端调用远程对象的方法时，实际上是调用了本地 Stub 上的方法。Stub 负责将方法调用和参数进行“封送”（marshaling，即将数据转换为网络可传输的格式），然后通过网络发送给服务器。
    - **Skeleton (服务器端骨架，在 Java 2 之后已不再强制使用)：** 曾经位于服务器端。它接收 Stub 发送过来的请求，将参数进行“解封”（unmarshaling），然后调用实际的远程对象方法，并将结果返回给 Stub。
    - 在现代 Java 版本中，Skeleton 的功能大部分已集成到 RMI 运行时环境中，开发者通常无需直接与 Skeleton 打交道。
5. **RMI Registry (RMI 注册表)：** 这是一个命名服务，服务器可以将远程对象的引用（带有唯一名称）绑定到注册表中。客户端可以通过这个名称在注册表中查找并获取远程对象的引用。
    
6. **序列化：** RMI 依赖 Java 的对象序列化机制来传输方法参数和返回值。这意味着所有作为参数传递或作为返回值返回的对象都必须是可序列化的 (`java.io.Serializable`)。
    

### RMI 的优点：

- **Java 原生支持：** RMI 是 Java 的一部分，与 Java 语言和对象模型紧密集成。
- **面向对象：** 允许直接在远程对象上调用方法，而不是像 RPC 那样只调用过程。支持传递对象作为参数和返回值，并保留对象的行为和类型。
- **分布式垃圾回收：** RMI 提供了一个分布式垃圾回收机制，帮助管理远程对象的生命周期。
- **抽象网络细节：** 开发者无需处理底层网络通信的复杂性（如 Socket 编程）。

### 局限性和替代方案：

尽管 RMI 是一种强大的分布式通信机制，但它主要用于 **Java-to-Java** 通信。如果需要与其他语言编写的系统进行通信，RMI 就显得力不从心。

随着技术的发展，出现了许多更灵活、更具互操作性的替代方案，例如：

- **Web Services (SOAP/REST):** 广泛用于异构系统之间的通信。RESTful API 因其简单性和无状态性而非常流行。
- **消息队列 (Message Queues):** 如 Kafka, RabbitMQ 等，用于构建异步、解耦的分布式系统。
- **gRPC:** 基于 Protocol Buffers 和 HTTP/2 的高性能 RPC 框架，支持多种语言。

因此，虽然 RMI 在过去广泛用于 Java 分布式应用，但在新的项目中，开发者通常会选择更现代、更具互操作性的技术。不过，理解 RMI 的概念对于理解分布式系统和 Java 历史仍然很有价值。