要落实容错性设计这条原则，除了思想观念上转变过来，正视程序必然是会出错的，对它进行有计划的防御之外，==还必须了解一些常用的**容错策略**和**容错设计模式**==，作为具体设计与编码实践的指导。这里容错策略指的是“面对故障，我们该做些什么”，稍后将讲解的容错设计模式指的是“要实现某种容错策略，我们该如何去做”。常见的容错策略有以下几种：

## **故障转移**（Failover）：
高可用的服务集群中，多数的服务——尤其是那些经常被其他服务所依赖的关键路径上的服务，均会部署有多个副本。这些副本可能部署在不同的节点（避免节点宕机）、不同的网络交换机（避免网络分区）甚至是不同的可用区（避免整个地区发生灾害或电力、骨干网故障）中。==故障转移是指如果调用的服务器出现故障，系统不会立即向调用者返回失败结果，而是自动切换到其他服务副本==，尝试其他副本能否返回成功调用的结果，从而保证了整体的高可用性。  

==故障转移的容错策略应该有一定的调用次数限制==，譬如允许最多重试三个服务，如果都发生报错，那还是会返回调用失败。原因不仅是因为重试是有执行成本的==，更是因为过度的重试反而可能让系统处于更加不利的状况==。譬如有以下调用链：Service A → Service B → Service C
  
假设 A 的超时阈值为 100 毫秒，而 B 调用 C 花费 60 毫秒，然后不幸失败了，这时候做故障转移其实已经没有太大意义了，因为即时下一次调用能够返回正确结果，也很可能同样需要耗费 60 毫秒时间，==时间总和就已经触及 A 服务的超时阈值，所以在这种情况下故障转移反而对系统是不利的。==
    
## **快速失败**
（Failfast）：还有另外一些业务场景是不允许做故障转移的，故障转移策略能够实施的前提是要求服务具备幂等性，==对于非幂等的服务，重复调用就可能产生脏数据，引起的麻烦远大于单纯的某次服务调用失败==，此时就应该以快速失败作为首选的容错策略。譬如，在支付场景中，需要调用银行的扣款接口，如果该接口返回的结果是网络异常，程序是很难判断到底是扣款指令发送给银行时出现的网络异常，还是银行扣款后返回结果给服务时出现的网络异常的。为了避免重复扣款，此时最恰当可行的方案就是==尽快让服务报错，坚决避免重试，尽快抛出异常==，由调用者自行处理。
    
## **安全失败**
（Failsafe）：在一个调用链路中的服务通常也有主路和旁路之分，并不见得其中每个服务都是不可或缺的，有部分服务失败了也不影响核心业务的正确性。==譬如开发基于 Spring 管理的应用程序时，通过扩展点、事件或者 AOP 注入的逻辑往往就属于旁路逻辑，典型的有审计、日志、调试信息，等等==。属于旁路逻辑的另一个显著特征是==后续处理不会依赖其返回值，或者它的返回值是什么都不会影响后续处理的结果==，譬如只是将返回值记录到数据库，并不使用它参与最终结果的运算。对这类逻辑，一种理想的容错策略是即使旁路逻辑调用实际失败了，==也当作正确来返回，如果需要返回值的话，系统就自动返回一个符合要求的数据类型的对应零值，然后自动记录一条服务调用出错的日志备查即可==，这种策略被称为安全失败。
    
## **沉默失败**
（Failsilent）：==如果大量的请求需要等到超时（或者长时间处理后）才宣告失败==，很容易由于某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源，进而影响到整个系统的稳定。面对这种情况，==一种合理的失败策略是当请求失败后，就默认服务提供者一定时间内无法再对外提供服务==，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略。
    
## **故障恢复**
（Failback）：==故障恢复一般不单独存在，而是作为其他容错策略的补充措施==，一般在微服务管理框架中，如果设置容错策略为故障恢复的话，通常默认会采用快速失败加上故障恢复的策略组合。它是指当服务调用出错了以后，==将该次调用失败的信息存入一个消息队列中，然后由系统自动开始异步重试调用==。 

故障恢复策略一方面是尽力促使失败的调用最终能够被正常执行，另一方面也可以为服务注册中心和负载均衡器及时提供服务恢复的通知信息。==故障恢复显然也是要求服务必须具备幂等性的==，由于它的重试是后台异步进行，即使最后调用成功了，原来的请求也早已经响应完毕，==所以故障恢复策略一般用于对实时性要求不高的主路逻辑==，同时也适合处理那些不需要返回值的旁路逻辑。为了避免在内存中异步调用任务堆积，故障恢复与故障转移一样，应该有最大重试次数的限制。
    
## **并行调用**
（Forking）：上面五种以“Fail”开头的策略是针对调用失败时如何进行弥补的，以下这两种策略则是在调用之前就开始考虑如何获得最大的成功概率。并行调用策略很符合人们日常对一些重要环节进行的“双重保险”或者“多重保险”的处理思路，它是指一开始就同时向多个服务副本发起调用，只要有其中任何一个返回成功，那调用便宣告成功，这是一种在关键场景中使用更高的执行成本换取执行时间和成功概率的策略。
    
## **广播调用**
（Broadcast）：广播调用与并行调用是相对应的，都是同时发起多个调用，但并行调用是任何一个调用结果返回成功便宣告成功，广播调用则是要求所有的请求全部都成功，这次调用才算是成功，任何一个服务提供者出现异常都算调用失败，广播调用通常会被用于实现“刷新分布式缓存”这类的操作。

|容错策略|优点|缺点|应用场景|
|---|---|---|---|
|**故障转移**|系统自动处理，调用者对失败的信息不可见|增加调用时间，额外的资源开销|调用幂等服务  <br>对调用时间不敏感的场景|
|**快速失败**|调用者有对失败的处理完全控制权  <br>不依赖服务的幂等性|调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩|调用非幂等的服务  <br>超时阈值较低的场景|
|**安全失败**|不影响主路逻辑|只适用于旁路调用|调用链中的旁路服务|
|**沉默失败**|控制错误不影响全局|出错的地方将在一段时间内不可用|频繁超时的服务|
|**故障恢复**|调用失败后自动重试，也不影响主路逻辑|重试任务可能产生堆积，重试仍然可能失败|调用链中的旁路服务  <br>对实时性要求不高的主路逻辑也可以使用|
|**并行调用**|尽可能在最短时间内获得最高的成功率|额外消耗机器资源，大部分调用可能都是无用功|资源充足且对失败容忍度低的场景|
|**广播调用**|支持同时对批量的服务提供者发起调用|资源消耗大，失败概率高|只适用于批量操作的场景|