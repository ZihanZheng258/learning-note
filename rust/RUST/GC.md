是的，**Rust 没有垃圾回收器（Garbage Collector，简称 GC）**。

这是 Rust 最显著的特点之一，也是它能够实现高性能和内存安全的关键。

### GC 是什么，以及为什么 Rust 没有它？

在许多现代编程语言（如 Java、Python、Go 等）中，GC 负责自动管理内存。当程序中的变量不再被使用时，GC 会自动检测并回收其占用的内存。

这种方式的好处是：

- **方便**：程序员无需手动管理内存，可以专注于业务逻辑。
    
- **安全**：避免了内存泄漏、悬垂指针等常见问题。
    

但缺点也很明显：

- **性能开销**：GC 需要消耗额外的计算资源来运行，这可能会影响程序的性能。
    
- **不可预测性**：GC 运行时机通常不确定，可能导致程序在关键时刻出现卡顿（称为“GC 暂停”），这对于需要低延迟的应用（如游戏、实时系统）来说是不可接受的。

### Rust 如何在没有 GC 的情况下保证内存安全？

Rust 选择了另一种完全不同的方法来管理内存：**所有权系统（Ownership System）**。

所有权系统由以下三个核心概念组成，它们在编译时就强制执行，而不是在运行时：

1. **所有权（Ownership）**：每个值都有一个唯一的“所有者”变量。当所有者超出其作用域时，该值就会被自动销毁。
    
2. **移动（Move）和复制（Copy）**：所有权可以在变量之间转移。对于复杂类型，==所有权会“移动”，原变量失效；对于简单类型，所有值会“复制”，各自独立。==
    
3. **借用（Borrowing）**：你可以创建对值的“引用”来临时使用它，而无需获得其所有权。借用检查器（Borrow Checker）会确保引用在使用期间，其指向的值一直有效。
    

### 总结

因为所有权系统，Rust 可以在编译时就明确地知道：

- 内存何时被分配。
    
- 内存何时不再被需要。
    
- 内存何时可以被安全地释放。
    

这种机制使得 Rust 能够在**没有运行时开销**（不需要 GC）的情况下，自动、安全地管理内存，从而兼具**C/C++ 的高性能**和**现代语言的内存安全性**。这也是为什么 Rust 如此独特，并被广泛应用于对性能和安全要求极高的领域，如操作系统、嵌入式系统和网络服务。