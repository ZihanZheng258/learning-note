总结来说：

- **你可以从一个可变变量创建不可变引用。**
    
- **你不能从一个不可变变量创建任何引用。**

让我们用例子来详细说明一下。

### 1. 从可变变量创建不可变引用（√）

你可以从一个用 `let mut` 声明的变量创建一个不可变引用。这是因为不可变引用不会对数据造成任何改变，所以这是完全安全的。

```rust
fn main() {
    let mut s = String::from("hello"); // s 是可变变量
    
    // 从可变变量 s 创建一个不可变引用 r1
    let r1 = &s; 
    
    println!("{}", r1); // 没问题，可以使用 r1
}
```

这很常见，因为你可能需要一个可以被修改的变量，但在某个函数或代码块中，你只想安全地读取它的值，不想意外地改变它

### 从不可变变量创建可变引用（×）

这是不允许的。如果你有一个用 `let` 声明的不可变变量，你不能从它创建一个可变引用。

```rust
fn main() {
    let s = String::from("hello"); // s 是不可变变量
    
    // 错误！不能从不可变变量 s 创建可变引用
    let r1 = &mut s; 
}
```

Rust 会报错，告诉你“无法对不可变变量 `s` 进行可变借用”。这是完全符合逻辑的：如果一个变量被设计为不可变的，那么就不能通过任何方式（包括可变引用）来改变它。

### 3. 从不可变变量创建不可变引用（√）

当然，从一个不可变变量创建不可变引用是完全可以的。

```rust
fn main() {
    let s = String::from("hello"); // s 是不可变变量
    
    // 从不可变变量 s 创建一个不可变引用 r1
    let r1 = &s; 
    
    println!("{}", r1); // 没问题
}
```

### 总结

核心原则是：**引用的可变性不能比其所借用的变量更强。**

- 如果变量是**可变**的 (`mut`)，你可以创建可变引用或不可变引用。
    
- 如果变量是**不可变**的，你只能创建不可变引用。
    

这是 Rust **所有权和借用检查器**的核心安全规则之一。它保证了引用的行为不会违背原始变量的设计意图，从而在编译时防止了许多潜在的内存安全问题。