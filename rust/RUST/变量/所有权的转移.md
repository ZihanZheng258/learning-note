当所有权从一个变量转移到另一个变量时，原变量就失效了。这种转移也发生在作用域内。

```rust
fn main() {
    let s1 = String::from("hello"); // s1是"hello"的所有者
    
    let s2 = s1; // 所有权从s1转移给了s2
    
    // println!("{}", s1); // 错误！s1已经失效。
    
    println!("{}", s2); // s2现在是"hello"的唯一所有者，可以使用。
}
```

在这个例子中，`s1` 和 `s2` 都在同一个作用域内。但当 `s1` 的值被赋值给 `s2` 时，所有权发生了转移，`s1` 不再拥有这个值。

### 总结

- **所有权存在的范围** = **变量绑定的作用域**。
    
- **作用域**由**花括号 `{}`** 定义。
    
- 当一个值进入一个作用域时，它被创建，并由一个变量拥有所有权。
    
- 当代码执行到作用域结束的花括号时，该作用域内的所有变量及其拥有的值都会被自动**丢弃（drop）**，内存被回收。
    
- **所有权的转移**（**Move**）将所有权从一个变量传递给另一个变量，原变量立即失效，其所有权范围结束。
    

通过这种方式，Rust确保了每个值在任何时候都只有一个所有者，从而在编译时消除了数据竞争、空指针等内存安全问题。