在 Rust 中，**引用（references）** 是一种不同于变量、但与变量紧密相关的概念。它们允许你在不获取变量所有权的情况下，使用变量的值。

简单来说，==**引用就像是一个指向某个变量的指针，但它本身不拥有该变量**。==

### 为什么需要引用？

考虑一个场景：你有一个函数，需要使用一个很大的数据结构（比如一个大型向量 `Vec`）。如果你直接将这个向量作为参数传递给函数，Rust 的所有权机制会默认将所有权转移（move）给这个函数。==这意味着，当函数执行完毕后，这个向量会被销毁，你无法再在原始作用域中使用它。==

这显然效率很低，且不灵活。引用就是为了解决这个问题而生的。

### 借用（Borrowing）

创建引用的过程在 Rust 中被称为**借用（borrowing）**。当一个变量被借用时，它依然保留着自己的所有权。

我们用代码来解释：

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // 在这里我们借用了 s1
    println!("The length of '{}' is {}.", s1, len);
}
```

在上面的例子中：

- `&s1` 就是一个**引用**。它指向 `s1`，但没有获得 `s1` 的所有权。
    
- `calculate_length` 函数的参数 `s: &String` 声明它接收一个 `String` 类型的**引用**。
    
- 当函数 `calculate_length` 结束时，`s` 引用被丢弃，但 `s1` 仍然**拥有**它的值，可以继续使用。