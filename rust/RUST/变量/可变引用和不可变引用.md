和变量一样，引用也默认是不可变的。你不能通过一个不可变引用来修改它所指向的值。

**不可变引用（Immutable References）**:

```rust
let s = String::from("hello");
let r1 = &s;
let r2 = &s; // 你可以有多个不可变引用
// *r1 = "world"; // 错误！无法通过不可变引用修改值
```

**可变引用（Mutable References）**: 要修改值，你需要创建一个**可变引用**。

```rust
let mut s = String::from("hello");
let r1 = &mut s;
r1.push_str(", world"); // 可以通过可变引用修改值
println!("{}", s); // 输出 "hello, world"
```

### Rust 引用规则的核心

为了防止数据竞争（data races），Rust 对引用的使用制定了严格的规则。这些规则被称为 **借用检查器（Borrow Checker）**，它们在编译时就会检查你的代码。

核心规则是：**在任意给定时间，你只能拥有以下两者之一：**

1. **一个可变引用** (`&mut T`)。
    
2. **任意数量的不可变引用** (`&T`)。
    

这些规则确保了数据安全，避免了多线程编程中常见的并发问题。例如，当你在修改一个值时，不能同时有其他地方也在读取这个值，否则就会出现不确定的行为。

### 总结

- **变量** (`let`) 拥有数据的所有权。
    
- **引用** (`&`) 借用数据，它本身不拥有所有权，但可以让你访问数据。
    
- **不可变引用** (`&T`) 允许你读取数据，但不能修改。你可以同时创建多个不可变引用。
    
- **可变引用** (`&mut T`) 允许你修改数据。在同一时间，你只能创建一个可变引用。
    

通过这种“所有权”和“借用”的机制，Rust 能够在编译阶段就保证内存安全，避免了空指针、悬垂指针等一系列问题，而不需要垃圾回收器。