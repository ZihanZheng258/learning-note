Rust的变量默认是不可变的，这通常是Rust新手需要适应的最重要的概念之一。这种设计是为了帮助你编写出更安全、更并发的代码。

下面我们来详细聊聊Rust变量的几个核心概念。

### 变量的不可变性（Immutability）

当你声明一个变量时，它的值默认是不能被修改的。

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6; // 这行代码会引发编译错误！
}
```

编译器会给你一个错误提示，告诉你“不能对不可变变量`x`二次赋值”。

这种不可变性带来一个很大的好处：它能防止在不知情的情况下，代码中的某个地方意外地改变了变量的值，从而导致难以追踪的bug。

### 可变性（Mutability）

如果你确实需要一个可以修改的变量，你可以在`let`关键字后面加上`mut`来使其可变（mutable）。

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6; // 这次就没问题了
    println!("The new value of x is: {}", x);
}
```

这样，你就可以根据需要多次改变`x`的值。

### 变量遮蔽（Shadowing）

Rust允许你用一个新的同名变量来“遮蔽”（shadow）旧的变量。新的变量会“覆盖”旧的变量，并且是完全独立的。

这个特性特别有用，因为它可以让你在不改变变量可变性的情况下，对变量进行类型转换或值修改。

```rust
fn main() {
    let x = 5;
    let x = x + 1; // 遮蔽旧的x
    {
        let x = x * 2; // 在内部作用域再次遮蔽
        println!("The value of x in the inner scope is: {}", x); // 输出 12
    }
    println!("The value of x is: {}", x); // 输出 6
}
```