HTTP/2 引入了头部压缩技术，其中最关键的部分就是**静态表（Static Table）**和**动态表（Dynamic Table）**。它们共同构成了 **HPACK** 压缩算法，旨在减少 HTTP 请求和响应头部数据的重复传输，从而提高 Web 性能。

### 背景：为什么需要头部压缩？

在 HTTP/1.x 中，每个请求和响应都必须完整地发送其头部信息。这些头部信息通常包含许多重复的字段，比如 `Host`、`User-Agent`、`Accept` 等。对于一个包含大量小文件（如图片、CSS、JS）的网页，这会产生大量的冗余数据传输，降低了性能。

HTTP/2 的 HPACK 算法通过**引用**这些头部字段来解决这个问题。它维护两张表：一张是固定的静态表，另一张是会话期间不断变化的动态表。

### 1. 静态表（Static Table）

- **性质**：静态表是**预定义**的，客户端和服务器都**内置**了这张表。它的内容是**固定的，永不改变**。
    
- **作用**：它包含了 HTTP 协议中**最常用**的头部字段和值对，例如：
    
    - `":method: GET"`
        
    - `":status: 200"`
        
    - `":authority: "` (主机名)
        
    - `"content-type: text/plain"`
        
- **工作方式**：当一个头部字段和值对在静态表中存在时，客户端和服务器不需要传输完整的字符串，而只需传输一个**索引号**。例如，如果你要发送 `":method: GET"`，你只需要发送一个很小的数字 `2`，服务器就知道你指的是哪个字段。这极大地减少了数据量。
    

### 2. 动态表（Dynamic Table）

- **性质**：动态表是客户端和服务器在**会话期间**共同维护的一张表。它的内容是**动态变化的**，会话结束时会被清空。
    
- **作用**：它用于存储那些在**静态表中不存在==，但在当前会话中可能会重复出现**的头部字段和值对。==
    
- **工作方式**：
    
    1. 当客户端发送一个头部字段（比如一个自定义的 `Cookie` 或 `Authorization` 字段）时，==它会同时告诉服务器，将这个字段**添加到动态表**中。==
        
    2. 如果后续的请求再次包含这个字段，客户端就可以像使用静态表一样，发送一个小的**索引号**来引用它。
        
    3. 服务器收到请求后，会根据索引号查找动态表，找到对应的头部字段。
        

### 实例

假设客户端需要发送一个带有 `Cookie` 字段的请求：

- **第一次请求**：`Cookie: name=value; other=data`
    
    - 这个字段是自定义的，不在静态表中。
        
    - 客户端会发送完整的字段名和值，并告诉服务器将它**添加到动态表**中。
        
- **第二次请求**：
    
    - 客户端会查找动态表，发现这个 `Cookie` 字段已经有了索引（比如是 `62`）。
        
    - 客户端只需要发送**一个索引号**（`62`），服务器就知道你指的是哪个 `Cookie` 字段。