
BBR（Bottleneck Bandwidth and Round-trip propagation time）是 Google 在 2016 年开发的一种新型 **TCP 拥塞控制算法**。

它是为了解决传统 TCP 拥塞控制（如 CUBIC）在现代高速网络中所面临的问题而诞生的。简单来说，BBR 的目标是：**在不造成网络拥塞的前提下，尽可能地提高数据传输速度，并降低延迟。**

## 为什么需要 BBR？

传统的 TCP 拥塞控制算法主要依赖 **丢包** 作为网络拥塞的信号。

- **传统算法的问题（例如 CUBIC）**：当网络出现丢包时，它们会认为网络拥塞了，并大幅降低发送速率。但在现代网络中，**少量丢包可能只是偶然事件，并不总是意味着网络真的“满了”**。这会导致在高质量网络中，传输速率无法达到带宽的理论上限。
    
- **“缓冲膨胀”问题（Bufferbloat）**：为了应对网络波动，路由器等中间设备配备了越来越大的缓存。传统算法会持续发送数据直到填满这些缓存，这虽然避免了丢包，但会造成数据在缓存中长时间排队，从而导致**网络延迟（RTT）大幅增加**。
    

---

## BBR 的核心原理：基于模型而非丢包

BBR 解决问题的思路非常巧妙：它不再依靠丢包来猜测网络状况，==而是通过**主动测量**网络路径上的两个关键指标，来建立一个网络模型，从而精确控制发送速率。==

这两个关键指标是：

### 1. 瓶颈带宽（Bottleneck Bandwidth, BtlBw）

- **测量目标**：网络路径上最慢的那一跳（即瓶颈）能够处理数据的最大速率。
    
- **测量方法**：BBR 通过观察在某一时间段内**接收方确认了多少数据**，以及**发送这些数据所花费的时间**，来计算出当前的传输速率，并周期性地记录最大值作为 BtlBw。
    

### 2. 最小往返时延（Round-trip propagation time, RTprop）

- **测量目标**：数据包从发送方到接收方再返回所需要的最小时间（理想延迟）。
    
- **测量方法**：BBR 通过周期性地观察 TCP 连接中的**最小 RTT 值**。这个值不受缓冲膨胀的影响，代表了网络路径固有的延迟。
    

### BBR 的传输模型

BBR 认为，理想的发送速率应该等于 **带宽时延积（Bandwidth-Delay Product, BDP）**，即：

				BDP=BtlBw×RTprop

BDP 代表了在不造成缓冲膨胀的前提下，网络中应该保持在途（inflight）的数据总量。BBR 算法的目标就是将发送窗口大小维持在接近 BDP 的水平，以**“跑满”**带宽，同时**“不撑爆”**缓冲区，从而实现高吞吐量和低延迟。

## BBR 的优势和适用场景

| 优势       | 描述                                           |
| -------- | -------------------------------------------- |
| **高吞吐量** | 在跨越长距离、有轻微丢包的“长肥网络”（高带宽延迟积）中，BBR 能显著提升传输效率。  |
| **低延迟**  | BBR 通过最小化 RTprop 来限制在途数据量，有效对抗**缓冲膨胀**，降低延迟。 |
| **快速收敛** | 即使在网络环境变化时，==BBR 也能更快地找到并适应新的瓶颈带宽和最小延迟。==    |

BBR 特别适用于以下场景：

- **全球 CDN 网络**：提高跨洋数据分发速度。
    
- **视频流媒体**：减少视频卡顿和加载延迟。
    
- **高速云存储/数据中心**：提高大数据同步和备份的效率。
    

==BBR 已经被集成到 **Linux 内核**中（版本 4.9 及以上），可以简单地通过系统配置开启，而无需修改应用程序。==

