指针是一个变量，其存储的是值的地址，而不是值本身。在讨论指针之前，我们先看一看如何找到常规变量的地址。==只需对变量应用地址运算符（&），就可以获得它的位置==；例如，如果home是一个变量，则&home是它的地址。程序清单4.14演示了这个运算符的用法。

![[Pasted image 20250510191659.png]]
输出为

![[Pasted image 20250510191723.png]]


显示地址时，该实现的cout使用十六进制表示法，因为这是常用于描述内存的表示法（有些实现可能使用十进制表示法）。在该实现中，donuts的存储位置比cups要低。两个地址的差为0x0065fd44–
0x0065fd40（即4）。这是有意义的，因为donuts的类型为int，而这种类型使用4个字节。当然，不同系统给定的地址值可能不同。有些系统可能先存储cups，再存储donuts，这样两个地址值的差将为8个字节，因为cups的类型为double。另外，在有些系统中，可能不会将这两个变量存储在相邻的内存单元中。使用常规变量时，值是指定的量，而地址为派生量。下面来看看指针策略，它是C++内存管理编程理念的核心（参见旁注“指针与C++基本原理”）。

处理存储数据的新策略刚好相反，将地址视为指定的量，而将值视为派生量。一==种特殊类型的变量—指针用于存储值的地址。因此，指针名表示的是地址。\*运算符被称为间接值（indirectvelue）或解除引用（dereferencing）运算符，将其应用于指针，可以得到该地址处存储的值==（这和乘法使用的符号相同；C++根据上下文来确定所指的是乘法还是解除引用）。例如，假设manly是一个指针，则manly表示的是一个地址，而\*manly表示存储在该地址处的值。\*manly与常规int变量等效。程序清单4.15说明了这几点，它还演示了如何声明指针。

![[Pasted image 20250510191909.png]]

![[Pasted image 20250510191915.png]]

![[Pasted image 20250510191922.png]]

从中可知，int变量updates和指针变量p_updates只不过是同一枚硬币的两面。变量updates表示值，并使用&运算符来获得地址；而变量p_updates表示地址，并使用\*运算符来获得值（参见图4.8）。由于p_updates指向updates，因此\*p_updates和updates完全等价。可以像使用int变量那样使用\*p_updates。正如程序清单4.15表明的，甚至可以将值赋给\*p_updates。这样做将修改指向的值，即updates。
