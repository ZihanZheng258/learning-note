对指针的工作方式有一定了解后，来看看它如何实现在程序运行时
分配内存。前面我们都将指针初始化为变量的地址；变量是在编译时分
配的有名称的内存，而指针只是为可以通过名称直接访问的内存提供了
一个别名。指针真正的用武之地在于，在运行阶段分配未命名的内存以
存储值。在这种情况下，只能通过指针来访问内存。在C语言中，可以
用库函数malloc( )来分配内存；在C++中仍然可以这样做，但C++还有
更好的方法—new运算符。

下面来试试这种新技术，在运行阶段为一个int值分配未命名的内
存，并使用指针来访问这个值。这里的关键所在是C++的new运算符。
程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长
度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋
给一个指针。下面是一个这样的示例：

![[Pasted image 20250510194100.png]]

new int告诉程序，需要适合存储int的内存。new运算符根据类型来

确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。

接下来，将地址赋给pn，pn是被声明为指向int的指针。现在，pn是地

址，而*pn是存储在那里的值。将这种方法与将变量的地址赋给指针进

行比较：

![[Pasted image 20250510194118.png]]

在这两种情况（pn和pt）下，都是将一个int变量的地址赋给了指

针。在第二种情况下，可以通过名称higgens来访问该int，在第一种情况

下，则只能通过该指针进行访问。这引出了一个问题：pn指向的内存没

有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不

是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变

量”更通用，它指的是为数据项分配的内存块。因此，变量也是数据对

象，但pn指向的内存不是变量。乍一看，处理数据对象的指针方法可能

不太好用，但它使程序在管理内存方面有更大的控制权。

为一个数据对象（可以是结构，也可以是基本类型）获得并指定分

配内存的通用格式如下：

![[Pasted image 20250510194156.png]]

需要在两个地方指定数据类型：用来指定需要什么样的内存和用来

声明合适的指针。当然，如果已经声明了相应类型的指针，则可以使用

该指针，而不用再声明一个新的指针。程序清单4.17演示了如何将new

用于两种不同的类型。

![[Pasted image 20250510194238.png]]
![[Pasted image 20250510194245.png]]


该程序输出
![[Pasted image 20250510194310.png]]
该程序使用new分别为int类型和double类型的数据对象分配内存。

这是在程序运行时进行的。指针pt和pd指向这两个数据对象，如果没有

它们，将无法访问这些内存单元。有了这两个指针，就可以像使用变量

那样使用*pt和*pd了。将值赋给*pt和*pd，从而将这些值赋给新的数据

对象。同样，可以通过打印*pt和*pd来显示这些值。

该程序还指出了必须声明指针所指向的类型的原因之一。地址本身

只指出了对象存储地址的开始，而没有指出其类型（使用的字节数）。

从这两个值的地址可以知道，它们都只是数字，并没有提供类型或长度

信息。另外，指向int的指针的长度与指向double的指针相同。它们都是

地址，但由于use_new.cpp声明了指针的类型，因此程序知道*pd是8个字

节的double值，*pt是4个字节的int值。use_new.cpp打印*pd的值时，cout

知道要读取多少字节以及如何解释它们。

对于指针，需要指出的另一点是，new分配的内存块通常与常规变

量声明分配的内存块不同。变量nights和pd的值都存储在被称为栈

（stack）的内存区域中，而new从被称为堆（heap）或自由存储区（free

store）的内存区域分配内存。第9章将更详细地讨论这一点。