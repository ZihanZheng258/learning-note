当编译器将源代码编译成目标文件（.o 文件），==然后**链接器**将这些目标文件以及库文件连接起来生成可执行文件时，**是否保留原有的符号表**取决于几个关键因素==：

### 1. 默认行为：调试信息

默认情况下，如果编译时包含了**调试信息**（通常通过在编译命令中添加 `-g` 选项），那么生成的可执行文件中会**保留一份符号表**。

- **调试符号表 (Debugging Symbol Table):** 这份符号表包含了源代码中定义的函数名、变量名、行号等信息，它们与编译后的机器代码地址相关联。
    
- **用途:**
    
    - **调试器 (Debuggers):** `gdb` 等调试工具正是依靠这些符号表信息，才能让你在调试时看到源代码变量名、函数调用栈，以及在特定行号设置断点。
        
    - **堆栈跟踪 (Stack Traces):** 当程序崩溃时，生成的堆栈跟踪信息会使用符号表来显示函数名，帮助你定位问题。


### 2. 发布版本：去除符号表

==对于发布给用户的最终可执行文件，通常会**去除符号表**==。这主要通过以下方式实现：

- **编译时省略调试信息:** 在编译阶段就不添加 `-g` 选项。
    
- **使用 `strip` 命令:** 即使在编译时包含了调试信息，也可以在链接完成后，使用 `strip` 命令来**剥离 (strip)** 可执行文件中的符号表和调试信息。
    
    Bash
    
    ```
    strip your_executable
    ```
    
    `strip` 命令会从可执行文件中移除：
    
    - **调试符号 (Debugging Symbols):** 这是最主要的部分，占用了大量空间。
        
    - **重定位信息 (Relocation Information):** 在动态链接时可能需要，但对于静态链接或最终的可执行文件通常可以移除。
        
- **目的:**
    
    - **减小可执行文件大小:** 符号表可能会非常大，移除后可以显著减小文件体积，这对于嵌入式系统、网络传输或存储空间有限的场景很重要。
        
    - **提高安全性/混淆:** 虽然不是绝对安全，但移除符号表可以增加逆向工程的难度，使得攻击者更难理解程序的内部结构。
        
    - **加快加载速度:** 较小的文件在加载时会更快。

### 3. 动态链接库 (.so 文件)

- **共享库 (.so 文件):** 对于动态链接库（Shared Objects），通常也会保留一份**必要的符号表**。这些符号表包含库中对外可见的函数和变量名，以便在运行时其他程序能够找到并调用它们。
    
- **可见性:** 这部分符号表是供链接器和动态加载器使用的，用于解析外部引用。它通常不包含详细的调试信息（除非特意编译）。


### 总结

==生成的可执行文件中是否保留原有符号表取决于**编译和链接时的选项以及后处理**。==

- 如果用于**开发和调试**，通常会**保留（通过 `-g` 选项）**，以便进行有效的调试。
    
- 如果用于**最终发布**，通常会**去除（通过不加 `-g` 或使用 `strip` 命令）**，以减小文件大小、提高加载速度和增加一定的混淆。