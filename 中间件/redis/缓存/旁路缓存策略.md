# Cache Aside（旁路缓存）

"Cache Aside"或"旁路缓存"这个名字来源于其设计原理。在这种策略中，==应用程序直接与缓存和数据库进行交互，而不是通过缓存透明地访问数据库。==也就是说，缓存并没有处于数据访问的主路径（或者说“主路”）上，而是像一条“旁路”一样，需要应用程序显式地去读写它。

==当数据在缓存中未找到（缓存未命中）时，应用程序需要绕开缓存，直接从数据库中获取数据==，然后再将数据放入缓存中。同样，当数据更新时，应用程序也需要同时更新数据库和缓存。

==因此，这种策略被称为"Cache Aside"或"旁路缓存"，强调了应用程序需要直接管理缓存和数据库之间的同步==，而缓存并不自动地在主数据访问路径上进行更新或加载数据。

该策略又可以细分为读策略和写策略:

**写策略的步骤：**

- 先更新数据库中的数据，再删除缓存中的数据。

**读策略的步骤：**

- 如果读取的数据命中了缓存，则直接返回数据；
- 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。

==**Cache Aside 策略适合读多写少的场景，不适合写多的场景**==，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：

- ==一种做法是在更新数据时也更新缓存，只是在更新数据前先加一个分布式锁==，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；
- ==另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间==，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。