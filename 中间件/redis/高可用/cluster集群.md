## 1. 为什么需要Redis Cluster？

哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。

因此，Reids Cluster集群（切片集群的实现方案）应运而生，它在Redis3.0加入的，实现了Redis的分布式存储。==对数据进行分片，也就是说每台Redis节点上存储不同的内容==，来解决在线扩容的问题。并且，它可以保存大量数据，即分散数据到各个Redis实例，还提供复制和故障转移的功能。

这时候你很容易想到，把15G数据分散来存储就好了嘛。这就是Redis切片集群的初衷。

切片集群是啥呢？来看个例子，如果你要用Redis保存15G的数据，可以用单实例Redis，或者3台Redis实例组成切片集群，对比如下：

==既然数据是分片分布到不同Redis实例的，那客户端到底是怎么确定想要访问的数据在哪个实例上呢？

## 哈希槽

Redis Cluster方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。

一个切片集群被分为16384个slot（槽），==每个进入Redis的键值对，根据key进行散列，分配到这16384插槽中的一个==。使用的哈希映射也比较简单，用CRC16算法计算出一个16bit的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。

集群中的每个节点负责一部分的哈希槽，假设当前集群有A、B、C3个节点，每个节点上负责的哈希槽数 =16384/3，那么可能存在的一种分配：

节点A负责0~5460号哈希槽
节点B负责5461~10922号哈希槽
节点C负责10923~16383号哈希槽

## 实例上并没有相应的数据，会怎么样？(MOVED重定向和ASK重定向)

在Redis cluster模式下，节点对请求的处理过程如下：

1. 通过哈希槽映射，检查当前Redis key是否存在当前节点
2. ==若哈希槽不是由自身节点负责，就返回MOVED重定向==
3. 若哈希槽确实由自身负责，且key在slot中，则返回该key对应结果
4. 若Redis key不存在此哈希槽中，检查该哈希槽是否正在迁出（MIGRATING）？
5. 若Redis key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上
6. 若哈希槽未迁出，检查哈希槽是否导入中？
7. 若哈希槽导入中且有ASKING标记，则直接操作，否则返回MOVED重定向

### 3.1 Moved 重定向

==客户端给一个Redis实例发送数据读写操作时，如果计算出来的槽不是在该节点上，这时候它会返回MOVED重定向错误==，MOVED重定向错误中，会将哈希槽所在的新实例的IP和port端口带回去。这就是Redis Cluster的MOVED重定向机制。流程图如下：

![[Pasted image 20250514180248.png]]

## 3.2 ASK 重定向

==Ask重定向一般发生于集群伸缩的时候==。集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向可以解决此种情况。

![[Pasted image 20250514180501.png]]